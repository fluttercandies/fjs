// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'source.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$JsBuiltinOptions {
  bool? get abort;
  bool? get assert_;
  bool? get asyncHooks;
  bool? get buffer;
  bool? get childProcess;
  bool? get console;
  bool? get crypto;
  bool? get dns;
  bool? get events;
  bool? get exceptions;
  bool? get fetch;
  bool? get fs;
  bool? get navigator;
  bool? get net;
  bool? get os;
  bool? get path;
  bool? get perfHooks;
  bool? get process;
  bool? get streamWeb;
  bool? get stringDecoder;
  bool? get timers;
  bool? get tty;
  bool? get url;
  bool? get util;
  bool? get zlib;
  bool? get json;

  /// Create a copy of JsBuiltinOptions
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $JsBuiltinOptionsCopyWith<JsBuiltinOptions> get copyWith =>
      _$JsBuiltinOptionsCopyWithImpl<JsBuiltinOptions>(
          this as JsBuiltinOptions, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is JsBuiltinOptions &&
            (identical(other.abort, abort) || other.abort == abort) &&
            (identical(other.assert_, assert_) || other.assert_ == assert_) &&
            (identical(other.asyncHooks, asyncHooks) ||
                other.asyncHooks == asyncHooks) &&
            (identical(other.buffer, buffer) || other.buffer == buffer) &&
            (identical(other.childProcess, childProcess) ||
                other.childProcess == childProcess) &&
            (identical(other.console, console) || other.console == console) &&
            (identical(other.crypto, crypto) || other.crypto == crypto) &&
            (identical(other.dns, dns) || other.dns == dns) &&
            (identical(other.events, events) || other.events == events) &&
            (identical(other.exceptions, exceptions) ||
                other.exceptions == exceptions) &&
            (identical(other.fetch, fetch) || other.fetch == fetch) &&
            (identical(other.fs, fs) || other.fs == fs) &&
            (identical(other.navigator, navigator) ||
                other.navigator == navigator) &&
            (identical(other.net, net) || other.net == net) &&
            (identical(other.os, os) || other.os == os) &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.perfHooks, perfHooks) ||
                other.perfHooks == perfHooks) &&
            (identical(other.process, process) || other.process == process) &&
            (identical(other.streamWeb, streamWeb) ||
                other.streamWeb == streamWeb) &&
            (identical(other.stringDecoder, stringDecoder) ||
                other.stringDecoder == stringDecoder) &&
            (identical(other.timers, timers) || other.timers == timers) &&
            (identical(other.tty, tty) || other.tty == tty) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.util, util) || other.util == util) &&
            (identical(other.zlib, zlib) || other.zlib == zlib) &&
            (identical(other.json, json) || other.json == json));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        abort,
        assert_,
        asyncHooks,
        buffer,
        childProcess,
        console,
        crypto,
        dns,
        events,
        exceptions,
        fetch,
        fs,
        navigator,
        net,
        os,
        path,
        perfHooks,
        process,
        streamWeb,
        stringDecoder,
        timers,
        tty,
        url,
        util,
        zlib,
        json
      ]);

  @override
  String toString() {
    return 'JsBuiltinOptions(abort: $abort, assert_: $assert_, asyncHooks: $asyncHooks, buffer: $buffer, childProcess: $childProcess, console: $console, crypto: $crypto, dns: $dns, events: $events, exceptions: $exceptions, fetch: $fetch, fs: $fs, navigator: $navigator, net: $net, os: $os, path: $path, perfHooks: $perfHooks, process: $process, streamWeb: $streamWeb, stringDecoder: $stringDecoder, timers: $timers, tty: $tty, url: $url, util: $util, zlib: $zlib, json: $json)';
  }
}

/// @nodoc
abstract mixin class $JsBuiltinOptionsCopyWith<$Res> {
  factory $JsBuiltinOptionsCopyWith(
          JsBuiltinOptions value, $Res Function(JsBuiltinOptions) _then) =
      _$JsBuiltinOptionsCopyWithImpl;
  @useResult
  $Res call(
      {bool? abort,
      bool? assert_,
      bool? asyncHooks,
      bool? buffer,
      bool? childProcess,
      bool? console,
      bool? crypto,
      bool? dns,
      bool? events,
      bool? exceptions,
      bool? fetch,
      bool? fs,
      bool? navigator,
      bool? net,
      bool? os,
      bool? path,
      bool? perfHooks,
      bool? process,
      bool? streamWeb,
      bool? stringDecoder,
      bool? timers,
      bool? tty,
      bool? url,
      bool? util,
      bool? zlib,
      bool? json});
}

/// @nodoc
class _$JsBuiltinOptionsCopyWithImpl<$Res>
    implements $JsBuiltinOptionsCopyWith<$Res> {
  _$JsBuiltinOptionsCopyWithImpl(this._self, this._then);

  final JsBuiltinOptions _self;
  final $Res Function(JsBuiltinOptions) _then;

  /// Create a copy of JsBuiltinOptions
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? abort = freezed,
    Object? assert_ = freezed,
    Object? asyncHooks = freezed,
    Object? buffer = freezed,
    Object? childProcess = freezed,
    Object? console = freezed,
    Object? crypto = freezed,
    Object? dns = freezed,
    Object? events = freezed,
    Object? exceptions = freezed,
    Object? fetch = freezed,
    Object? fs = freezed,
    Object? navigator = freezed,
    Object? net = freezed,
    Object? os = freezed,
    Object? path = freezed,
    Object? perfHooks = freezed,
    Object? process = freezed,
    Object? streamWeb = freezed,
    Object? stringDecoder = freezed,
    Object? timers = freezed,
    Object? tty = freezed,
    Object? url = freezed,
    Object? util = freezed,
    Object? zlib = freezed,
    Object? json = freezed,
  }) {
    return _then(_self.copyWith(
      abort: freezed == abort
          ? _self.abort
          : abort // ignore: cast_nullable_to_non_nullable
              as bool?,
      assert_: freezed == assert_
          ? _self.assert_
          : assert_ // ignore: cast_nullable_to_non_nullable
              as bool?,
      asyncHooks: freezed == asyncHooks
          ? _self.asyncHooks
          : asyncHooks // ignore: cast_nullable_to_non_nullable
              as bool?,
      buffer: freezed == buffer
          ? _self.buffer
          : buffer // ignore: cast_nullable_to_non_nullable
              as bool?,
      childProcess: freezed == childProcess
          ? _self.childProcess
          : childProcess // ignore: cast_nullable_to_non_nullable
              as bool?,
      console: freezed == console
          ? _self.console
          : console // ignore: cast_nullable_to_non_nullable
              as bool?,
      crypto: freezed == crypto
          ? _self.crypto
          : crypto // ignore: cast_nullable_to_non_nullable
              as bool?,
      dns: freezed == dns
          ? _self.dns
          : dns // ignore: cast_nullable_to_non_nullable
              as bool?,
      events: freezed == events
          ? _self.events
          : events // ignore: cast_nullable_to_non_nullable
              as bool?,
      exceptions: freezed == exceptions
          ? _self.exceptions
          : exceptions // ignore: cast_nullable_to_non_nullable
              as bool?,
      fetch: freezed == fetch
          ? _self.fetch
          : fetch // ignore: cast_nullable_to_non_nullable
              as bool?,
      fs: freezed == fs
          ? _self.fs
          : fs // ignore: cast_nullable_to_non_nullable
              as bool?,
      navigator: freezed == navigator
          ? _self.navigator
          : navigator // ignore: cast_nullable_to_non_nullable
              as bool?,
      net: freezed == net
          ? _self.net
          : net // ignore: cast_nullable_to_non_nullable
              as bool?,
      os: freezed == os
          ? _self.os
          : os // ignore: cast_nullable_to_non_nullable
              as bool?,
      path: freezed == path
          ? _self.path
          : path // ignore: cast_nullable_to_non_nullable
              as bool?,
      perfHooks: freezed == perfHooks
          ? _self.perfHooks
          : perfHooks // ignore: cast_nullable_to_non_nullable
              as bool?,
      process: freezed == process
          ? _self.process
          : process // ignore: cast_nullable_to_non_nullable
              as bool?,
      streamWeb: freezed == streamWeb
          ? _self.streamWeb
          : streamWeb // ignore: cast_nullable_to_non_nullable
              as bool?,
      stringDecoder: freezed == stringDecoder
          ? _self.stringDecoder
          : stringDecoder // ignore: cast_nullable_to_non_nullable
              as bool?,
      timers: freezed == timers
          ? _self.timers
          : timers // ignore: cast_nullable_to_non_nullable
              as bool?,
      tty: freezed == tty
          ? _self.tty
          : tty // ignore: cast_nullable_to_non_nullable
              as bool?,
      url: freezed == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as bool?,
      util: freezed == util
          ? _self.util
          : util // ignore: cast_nullable_to_non_nullable
              as bool?,
      zlib: freezed == zlib
          ? _self.zlib
          : zlib // ignore: cast_nullable_to_non_nullable
              as bool?,
      json: freezed == json
          ? _self.json
          : json // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [JsBuiltinOptions].
extension JsBuiltinOptionsPatterns on JsBuiltinOptions {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_JsBuiltinOptions value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JsBuiltinOptions() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_JsBuiltinOptions value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JsBuiltinOptions():
        return $default(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_JsBuiltinOptions value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JsBuiltinOptions() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            bool? abort,
            bool? assert_,
            bool? asyncHooks,
            bool? buffer,
            bool? childProcess,
            bool? console,
            bool? crypto,
            bool? dns,
            bool? events,
            bool? exceptions,
            bool? fetch,
            bool? fs,
            bool? navigator,
            bool? net,
            bool? os,
            bool? path,
            bool? perfHooks,
            bool? process,
            bool? streamWeb,
            bool? stringDecoder,
            bool? timers,
            bool? tty,
            bool? url,
            bool? util,
            bool? zlib,
            bool? json)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JsBuiltinOptions() when $default != null:
        return $default(
            _that.abort,
            _that.assert_,
            _that.asyncHooks,
            _that.buffer,
            _that.childProcess,
            _that.console,
            _that.crypto,
            _that.dns,
            _that.events,
            _that.exceptions,
            _that.fetch,
            _that.fs,
            _that.navigator,
            _that.net,
            _that.os,
            _that.path,
            _that.perfHooks,
            _that.process,
            _that.streamWeb,
            _that.stringDecoder,
            _that.timers,
            _that.tty,
            _that.url,
            _that.util,
            _that.zlib,
            _that.json);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            bool? abort,
            bool? assert_,
            bool? asyncHooks,
            bool? buffer,
            bool? childProcess,
            bool? console,
            bool? crypto,
            bool? dns,
            bool? events,
            bool? exceptions,
            bool? fetch,
            bool? fs,
            bool? navigator,
            bool? net,
            bool? os,
            bool? path,
            bool? perfHooks,
            bool? process,
            bool? streamWeb,
            bool? stringDecoder,
            bool? timers,
            bool? tty,
            bool? url,
            bool? util,
            bool? zlib,
            bool? json)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JsBuiltinOptions():
        return $default(
            _that.abort,
            _that.assert_,
            _that.asyncHooks,
            _that.buffer,
            _that.childProcess,
            _that.console,
            _that.crypto,
            _that.dns,
            _that.events,
            _that.exceptions,
            _that.fetch,
            _that.fs,
            _that.navigator,
            _that.net,
            _that.os,
            _that.path,
            _that.perfHooks,
            _that.process,
            _that.streamWeb,
            _that.stringDecoder,
            _that.timers,
            _that.tty,
            _that.url,
            _that.util,
            _that.zlib,
            _that.json);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            bool? abort,
            bool? assert_,
            bool? asyncHooks,
            bool? buffer,
            bool? childProcess,
            bool? console,
            bool? crypto,
            bool? dns,
            bool? events,
            bool? exceptions,
            bool? fetch,
            bool? fs,
            bool? navigator,
            bool? net,
            bool? os,
            bool? path,
            bool? perfHooks,
            bool? process,
            bool? streamWeb,
            bool? stringDecoder,
            bool? timers,
            bool? tty,
            bool? url,
            bool? util,
            bool? zlib,
            bool? json)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JsBuiltinOptions() when $default != null:
        return $default(
            _that.abort,
            _that.assert_,
            _that.asyncHooks,
            _that.buffer,
            _that.childProcess,
            _that.console,
            _that.crypto,
            _that.dns,
            _that.events,
            _that.exceptions,
            _that.fetch,
            _that.fs,
            _that.navigator,
            _that.net,
            _that.os,
            _that.path,
            _that.perfHooks,
            _that.process,
            _that.streamWeb,
            _that.stringDecoder,
            _that.timers,
            _that.tty,
            _that.url,
            _that.util,
            _that.zlib,
            _that.json);
      case _:
        return null;
    }
  }
}

/// @nodoc

class _JsBuiltinOptions extends JsBuiltinOptions {
  const _JsBuiltinOptions(
      {this.abort,
      this.assert_,
      this.asyncHooks,
      this.buffer,
      this.childProcess,
      this.console,
      this.crypto,
      this.dns,
      this.events,
      this.exceptions,
      this.fetch,
      this.fs,
      this.navigator,
      this.net,
      this.os,
      this.path,
      this.perfHooks,
      this.process,
      this.streamWeb,
      this.stringDecoder,
      this.timers,
      this.tty,
      this.url,
      this.util,
      this.zlib,
      this.json})
      : super._();

  @override
  final bool? abort;
  @override
  final bool? assert_;
  @override
  final bool? asyncHooks;
  @override
  final bool? buffer;
  @override
  final bool? childProcess;
  @override
  final bool? console;
  @override
  final bool? crypto;
  @override
  final bool? dns;
  @override
  final bool? events;
  @override
  final bool? exceptions;
  @override
  final bool? fetch;
  @override
  final bool? fs;
  @override
  final bool? navigator;
  @override
  final bool? net;
  @override
  final bool? os;
  @override
  final bool? path;
  @override
  final bool? perfHooks;
  @override
  final bool? process;
  @override
  final bool? streamWeb;
  @override
  final bool? stringDecoder;
  @override
  final bool? timers;
  @override
  final bool? tty;
  @override
  final bool? url;
  @override
  final bool? util;
  @override
  final bool? zlib;
  @override
  final bool? json;

  /// Create a copy of JsBuiltinOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$JsBuiltinOptionsCopyWith<_JsBuiltinOptions> get copyWith =>
      __$JsBuiltinOptionsCopyWithImpl<_JsBuiltinOptions>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _JsBuiltinOptions &&
            (identical(other.abort, abort) || other.abort == abort) &&
            (identical(other.assert_, assert_) || other.assert_ == assert_) &&
            (identical(other.asyncHooks, asyncHooks) ||
                other.asyncHooks == asyncHooks) &&
            (identical(other.buffer, buffer) || other.buffer == buffer) &&
            (identical(other.childProcess, childProcess) ||
                other.childProcess == childProcess) &&
            (identical(other.console, console) || other.console == console) &&
            (identical(other.crypto, crypto) || other.crypto == crypto) &&
            (identical(other.dns, dns) || other.dns == dns) &&
            (identical(other.events, events) || other.events == events) &&
            (identical(other.exceptions, exceptions) ||
                other.exceptions == exceptions) &&
            (identical(other.fetch, fetch) || other.fetch == fetch) &&
            (identical(other.fs, fs) || other.fs == fs) &&
            (identical(other.navigator, navigator) ||
                other.navigator == navigator) &&
            (identical(other.net, net) || other.net == net) &&
            (identical(other.os, os) || other.os == os) &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.perfHooks, perfHooks) ||
                other.perfHooks == perfHooks) &&
            (identical(other.process, process) || other.process == process) &&
            (identical(other.streamWeb, streamWeb) ||
                other.streamWeb == streamWeb) &&
            (identical(other.stringDecoder, stringDecoder) ||
                other.stringDecoder == stringDecoder) &&
            (identical(other.timers, timers) || other.timers == timers) &&
            (identical(other.tty, tty) || other.tty == tty) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.util, util) || other.util == util) &&
            (identical(other.zlib, zlib) || other.zlib == zlib) &&
            (identical(other.json, json) || other.json == json));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        abort,
        assert_,
        asyncHooks,
        buffer,
        childProcess,
        console,
        crypto,
        dns,
        events,
        exceptions,
        fetch,
        fs,
        navigator,
        net,
        os,
        path,
        perfHooks,
        process,
        streamWeb,
        stringDecoder,
        timers,
        tty,
        url,
        util,
        zlib,
        json
      ]);

  @override
  String toString() {
    return 'JsBuiltinOptions(abort: $abort, assert_: $assert_, asyncHooks: $asyncHooks, buffer: $buffer, childProcess: $childProcess, console: $console, crypto: $crypto, dns: $dns, events: $events, exceptions: $exceptions, fetch: $fetch, fs: $fs, navigator: $navigator, net: $net, os: $os, path: $path, perfHooks: $perfHooks, process: $process, streamWeb: $streamWeb, stringDecoder: $stringDecoder, timers: $timers, tty: $tty, url: $url, util: $util, zlib: $zlib, json: $json)';
  }
}

/// @nodoc
abstract mixin class _$JsBuiltinOptionsCopyWith<$Res>
    implements $JsBuiltinOptionsCopyWith<$Res> {
  factory _$JsBuiltinOptionsCopyWith(
          _JsBuiltinOptions value, $Res Function(_JsBuiltinOptions) _then) =
      __$JsBuiltinOptionsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {bool? abort,
      bool? assert_,
      bool? asyncHooks,
      bool? buffer,
      bool? childProcess,
      bool? console,
      bool? crypto,
      bool? dns,
      bool? events,
      bool? exceptions,
      bool? fetch,
      bool? fs,
      bool? navigator,
      bool? net,
      bool? os,
      bool? path,
      bool? perfHooks,
      bool? process,
      bool? streamWeb,
      bool? stringDecoder,
      bool? timers,
      bool? tty,
      bool? url,
      bool? util,
      bool? zlib,
      bool? json});
}

/// @nodoc
class __$JsBuiltinOptionsCopyWithImpl<$Res>
    implements _$JsBuiltinOptionsCopyWith<$Res> {
  __$JsBuiltinOptionsCopyWithImpl(this._self, this._then);

  final _JsBuiltinOptions _self;
  final $Res Function(_JsBuiltinOptions) _then;

  /// Create a copy of JsBuiltinOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? abort = freezed,
    Object? assert_ = freezed,
    Object? asyncHooks = freezed,
    Object? buffer = freezed,
    Object? childProcess = freezed,
    Object? console = freezed,
    Object? crypto = freezed,
    Object? dns = freezed,
    Object? events = freezed,
    Object? exceptions = freezed,
    Object? fetch = freezed,
    Object? fs = freezed,
    Object? navigator = freezed,
    Object? net = freezed,
    Object? os = freezed,
    Object? path = freezed,
    Object? perfHooks = freezed,
    Object? process = freezed,
    Object? streamWeb = freezed,
    Object? stringDecoder = freezed,
    Object? timers = freezed,
    Object? tty = freezed,
    Object? url = freezed,
    Object? util = freezed,
    Object? zlib = freezed,
    Object? json = freezed,
  }) {
    return _then(_JsBuiltinOptions(
      abort: freezed == abort
          ? _self.abort
          : abort // ignore: cast_nullable_to_non_nullable
              as bool?,
      assert_: freezed == assert_
          ? _self.assert_
          : assert_ // ignore: cast_nullable_to_non_nullable
              as bool?,
      asyncHooks: freezed == asyncHooks
          ? _self.asyncHooks
          : asyncHooks // ignore: cast_nullable_to_non_nullable
              as bool?,
      buffer: freezed == buffer
          ? _self.buffer
          : buffer // ignore: cast_nullable_to_non_nullable
              as bool?,
      childProcess: freezed == childProcess
          ? _self.childProcess
          : childProcess // ignore: cast_nullable_to_non_nullable
              as bool?,
      console: freezed == console
          ? _self.console
          : console // ignore: cast_nullable_to_non_nullable
              as bool?,
      crypto: freezed == crypto
          ? _self.crypto
          : crypto // ignore: cast_nullable_to_non_nullable
              as bool?,
      dns: freezed == dns
          ? _self.dns
          : dns // ignore: cast_nullable_to_non_nullable
              as bool?,
      events: freezed == events
          ? _self.events
          : events // ignore: cast_nullable_to_non_nullable
              as bool?,
      exceptions: freezed == exceptions
          ? _self.exceptions
          : exceptions // ignore: cast_nullable_to_non_nullable
              as bool?,
      fetch: freezed == fetch
          ? _self.fetch
          : fetch // ignore: cast_nullable_to_non_nullable
              as bool?,
      fs: freezed == fs
          ? _self.fs
          : fs // ignore: cast_nullable_to_non_nullable
              as bool?,
      navigator: freezed == navigator
          ? _self.navigator
          : navigator // ignore: cast_nullable_to_non_nullable
              as bool?,
      net: freezed == net
          ? _self.net
          : net // ignore: cast_nullable_to_non_nullable
              as bool?,
      os: freezed == os
          ? _self.os
          : os // ignore: cast_nullable_to_non_nullable
              as bool?,
      path: freezed == path
          ? _self.path
          : path // ignore: cast_nullable_to_non_nullable
              as bool?,
      perfHooks: freezed == perfHooks
          ? _self.perfHooks
          : perfHooks // ignore: cast_nullable_to_non_nullable
              as bool?,
      process: freezed == process
          ? _self.process
          : process // ignore: cast_nullable_to_non_nullable
              as bool?,
      streamWeb: freezed == streamWeb
          ? _self.streamWeb
          : streamWeb // ignore: cast_nullable_to_non_nullable
              as bool?,
      stringDecoder: freezed == stringDecoder
          ? _self.stringDecoder
          : stringDecoder // ignore: cast_nullable_to_non_nullable
              as bool?,
      timers: freezed == timers
          ? _self.timers
          : timers // ignore: cast_nullable_to_non_nullable
              as bool?,
      tty: freezed == tty
          ? _self.tty
          : tty // ignore: cast_nullable_to_non_nullable
              as bool?,
      url: freezed == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as bool?,
      util: freezed == util
          ? _self.util
          : util // ignore: cast_nullable_to_non_nullable
              as bool?,
      zlib: freezed == zlib
          ? _self.zlib
          : zlib // ignore: cast_nullable_to_non_nullable
              as bool?,
      json: freezed == json
          ? _self.json
          : json // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$JsCode {
  Object get field0;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is JsCode &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @override
  String toString() {
    return 'JsCode(field0: $field0)';
  }
}

/// @nodoc
class $JsCodeCopyWith<$Res> {
  $JsCodeCopyWith(JsCode _, $Res Function(JsCode) __);
}

/// Adds pattern-matching-related methods to [JsCode].
extension JsCodePatterns on JsCode {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(JsCode_Code value)? code,
    TResult Function(JsCode_Path value)? path,
    TResult Function(JsCode_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case JsCode_Code() when code != null:
        return code(_that);
      case JsCode_Path() when path != null:
        return path(_that);
      case JsCode_Bytes() when bytes != null:
        return bytes(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(JsCode_Code value) code,
    required TResult Function(JsCode_Path value) path,
    required TResult Function(JsCode_Bytes value) bytes,
  }) {
    final _that = this;
    switch (_that) {
      case JsCode_Code():
        return code(_that);
      case JsCode_Path():
        return path(_that);
      case JsCode_Bytes():
        return bytes(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(JsCode_Code value)? code,
    TResult? Function(JsCode_Path value)? path,
    TResult? Function(JsCode_Bytes value)? bytes,
  }) {
    final _that = this;
    switch (_that) {
      case JsCode_Code() when code != null:
        return code(_that);
      case JsCode_Path() when path != null:
        return path(_that);
      case JsCode_Bytes() when bytes != null:
        return bytes(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? code,
    TResult Function(String field0)? path,
    TResult Function(Uint8List field0)? bytes,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case JsCode_Code() when code != null:
        return code(_that.field0);
      case JsCode_Path() when path != null:
        return path(_that.field0);
      case JsCode_Bytes() when bytes != null:
        return bytes(_that.field0);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) code,
    required TResult Function(String field0) path,
    required TResult Function(Uint8List field0) bytes,
  }) {
    final _that = this;
    switch (_that) {
      case JsCode_Code():
        return code(_that.field0);
      case JsCode_Path():
        return path(_that.field0);
      case JsCode_Bytes():
        return bytes(_that.field0);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? code,
    TResult? Function(String field0)? path,
    TResult? Function(Uint8List field0)? bytes,
  }) {
    final _that = this;
    switch (_that) {
      case JsCode_Code() when code != null:
        return code(_that.field0);
      case JsCode_Path() when path != null:
        return path(_that.field0);
      case JsCode_Bytes() when bytes != null:
        return bytes(_that.field0);
      case _:
        return null;
    }
  }
}

/// @nodoc

class JsCode_Code extends JsCode {
  const JsCode_Code(this.field0) : super._();

  @override
  final String field0;

  /// Create a copy of JsCode
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $JsCode_CodeCopyWith<JsCode_Code> get copyWith =>
      _$JsCode_CodeCopyWithImpl<JsCode_Code>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is JsCode_Code &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'JsCode.code(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $JsCode_CodeCopyWith<$Res>
    implements $JsCodeCopyWith<$Res> {
  factory $JsCode_CodeCopyWith(
          JsCode_Code value, $Res Function(JsCode_Code) _then) =
      _$JsCode_CodeCopyWithImpl;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class _$JsCode_CodeCopyWithImpl<$Res> implements $JsCode_CodeCopyWith<$Res> {
  _$JsCode_CodeCopyWithImpl(this._self, this._then);

  final JsCode_Code _self;
  final $Res Function(JsCode_Code) _then;

  /// Create a copy of JsCode
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(JsCode_Code(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class JsCode_Path extends JsCode {
  const JsCode_Path(this.field0) : super._();

  @override
  final String field0;

  /// Create a copy of JsCode
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $JsCode_PathCopyWith<JsCode_Path> get copyWith =>
      _$JsCode_PathCopyWithImpl<JsCode_Path>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is JsCode_Path &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'JsCode.path(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $JsCode_PathCopyWith<$Res>
    implements $JsCodeCopyWith<$Res> {
  factory $JsCode_PathCopyWith(
          JsCode_Path value, $Res Function(JsCode_Path) _then) =
      _$JsCode_PathCopyWithImpl;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class _$JsCode_PathCopyWithImpl<$Res> implements $JsCode_PathCopyWith<$Res> {
  _$JsCode_PathCopyWithImpl(this._self, this._then);

  final JsCode_Path _self;
  final $Res Function(JsCode_Path) _then;

  /// Create a copy of JsCode
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(JsCode_Path(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class JsCode_Bytes extends JsCode {
  const JsCode_Bytes(this.field0) : super._();

  @override
  final Uint8List field0;

  /// Create a copy of JsCode
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $JsCode_BytesCopyWith<JsCode_Bytes> get copyWith =>
      _$JsCode_BytesCopyWithImpl<JsCode_Bytes>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is JsCode_Bytes &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @override
  String toString() {
    return 'JsCode.bytes(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $JsCode_BytesCopyWith<$Res>
    implements $JsCodeCopyWith<$Res> {
  factory $JsCode_BytesCopyWith(
          JsCode_Bytes value, $Res Function(JsCode_Bytes) _then) =
      _$JsCode_BytesCopyWithImpl;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class _$JsCode_BytesCopyWithImpl<$Res> implements $JsCode_BytesCopyWith<$Res> {
  _$JsCode_BytesCopyWithImpl(this._self, this._then);

  final JsCode_Bytes _self;
  final $Res Function(JsCode_Bytes) _then;

  /// Create a copy of JsCode
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(JsCode_Bytes(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc
mixin _$JsEvalOptions {
  bool? get global;
  bool? get strict;
  bool? get backtraceBarrier;
  bool? get promise;

  /// Create a copy of JsEvalOptions
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $JsEvalOptionsCopyWith<JsEvalOptions> get copyWith =>
      _$JsEvalOptionsCopyWithImpl<JsEvalOptions>(
          this as JsEvalOptions, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is JsEvalOptions &&
            (identical(other.global, global) || other.global == global) &&
            (identical(other.strict, strict) || other.strict == strict) &&
            (identical(other.backtraceBarrier, backtraceBarrier) ||
                other.backtraceBarrier == backtraceBarrier) &&
            (identical(other.promise, promise) || other.promise == promise));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, global, strict, backtraceBarrier, promise);

  @override
  String toString() {
    return 'JsEvalOptions(global: $global, strict: $strict, backtraceBarrier: $backtraceBarrier, promise: $promise)';
  }
}

/// @nodoc
abstract mixin class $JsEvalOptionsCopyWith<$Res> {
  factory $JsEvalOptionsCopyWith(
          JsEvalOptions value, $Res Function(JsEvalOptions) _then) =
      _$JsEvalOptionsCopyWithImpl;
  @useResult
  $Res call(
      {bool? global, bool? strict, bool? backtraceBarrier, bool? promise});
}

/// @nodoc
class _$JsEvalOptionsCopyWithImpl<$Res>
    implements $JsEvalOptionsCopyWith<$Res> {
  _$JsEvalOptionsCopyWithImpl(this._self, this._then);

  final JsEvalOptions _self;
  final $Res Function(JsEvalOptions) _then;

  /// Create a copy of JsEvalOptions
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? global = freezed,
    Object? strict = freezed,
    Object? backtraceBarrier = freezed,
    Object? promise = freezed,
  }) {
    return _then(_self.copyWith(
      global: freezed == global
          ? _self.global
          : global // ignore: cast_nullable_to_non_nullable
              as bool?,
      strict: freezed == strict
          ? _self.strict
          : strict // ignore: cast_nullable_to_non_nullable
              as bool?,
      backtraceBarrier: freezed == backtraceBarrier
          ? _self.backtraceBarrier
          : backtraceBarrier // ignore: cast_nullable_to_non_nullable
              as bool?,
      promise: freezed == promise
          ? _self.promise
          : promise // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [JsEvalOptions].
extension JsEvalOptionsPatterns on JsEvalOptions {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_JsEvalOptions value)? raw,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JsEvalOptions() when raw != null:
        return raw(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_JsEvalOptions value) raw,
  }) {
    final _that = this;
    switch (_that) {
      case _JsEvalOptions():
        return raw(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_JsEvalOptions value)? raw,
  }) {
    final _that = this;
    switch (_that) {
      case _JsEvalOptions() when raw != null:
        return raw(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            bool? global, bool? strict, bool? backtraceBarrier, bool? promise)?
        raw,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JsEvalOptions() when raw != null:
        return raw(
            _that.global, _that.strict, _that.backtraceBarrier, _that.promise);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            bool? global, bool? strict, bool? backtraceBarrier, bool? promise)
        raw,
  }) {
    final _that = this;
    switch (_that) {
      case _JsEvalOptions():
        return raw(
            _that.global, _that.strict, _that.backtraceBarrier, _that.promise);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            bool? global, bool? strict, bool? backtraceBarrier, bool? promise)?
        raw,
  }) {
    final _that = this;
    switch (_that) {
      case _JsEvalOptions() when raw != null:
        return raw(
            _that.global, _that.strict, _that.backtraceBarrier, _that.promise);
      case _:
        return null;
    }
  }
}

/// @nodoc

class _JsEvalOptions extends JsEvalOptions {
  const _JsEvalOptions(
      {this.global, this.strict, this.backtraceBarrier, this.promise})
      : super._();

  @override
  final bool? global;
  @override
  final bool? strict;
  @override
  final bool? backtraceBarrier;
  @override
  final bool? promise;

  /// Create a copy of JsEvalOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$JsEvalOptionsCopyWith<_JsEvalOptions> get copyWith =>
      __$JsEvalOptionsCopyWithImpl<_JsEvalOptions>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _JsEvalOptions &&
            (identical(other.global, global) || other.global == global) &&
            (identical(other.strict, strict) || other.strict == strict) &&
            (identical(other.backtraceBarrier, backtraceBarrier) ||
                other.backtraceBarrier == backtraceBarrier) &&
            (identical(other.promise, promise) || other.promise == promise));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, global, strict, backtraceBarrier, promise);

  @override
  String toString() {
    return 'JsEvalOptions.raw(global: $global, strict: $strict, backtraceBarrier: $backtraceBarrier, promise: $promise)';
  }
}

/// @nodoc
abstract mixin class _$JsEvalOptionsCopyWith<$Res>
    implements $JsEvalOptionsCopyWith<$Res> {
  factory _$JsEvalOptionsCopyWith(
          _JsEvalOptions value, $Res Function(_JsEvalOptions) _then) =
      __$JsEvalOptionsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {bool? global, bool? strict, bool? backtraceBarrier, bool? promise});
}

/// @nodoc
class __$JsEvalOptionsCopyWithImpl<$Res>
    implements _$JsEvalOptionsCopyWith<$Res> {
  __$JsEvalOptionsCopyWithImpl(this._self, this._then);

  final _JsEvalOptions _self;
  final $Res Function(_JsEvalOptions) _then;

  /// Create a copy of JsEvalOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? global = freezed,
    Object? strict = freezed,
    Object? backtraceBarrier = freezed,
    Object? promise = freezed,
  }) {
    return _then(_JsEvalOptions(
      global: freezed == global
          ? _self.global
          : global // ignore: cast_nullable_to_non_nullable
              as bool?,
      strict: freezed == strict
          ? _self.strict
          : strict // ignore: cast_nullable_to_non_nullable
              as bool?,
      backtraceBarrier: freezed == backtraceBarrier
          ? _self.backtraceBarrier
          : backtraceBarrier // ignore: cast_nullable_to_non_nullable
              as bool?,
      promise: freezed == promise
          ? _self.promise
          : promise // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$JsModule {
  String get name;
  JsCode get source;

  /// Create a copy of JsModule
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $JsModuleCopyWith<JsModule> get copyWith =>
      _$JsModuleCopyWithImpl<JsModule>(this as JsModule, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is JsModule &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.source, source) || other.source == source));
  }

  @override
  int get hashCode => Object.hash(runtimeType, name, source);

  @override
  String toString() {
    return 'JsModule(name: $name, source: $source)';
  }
}

/// @nodoc
abstract mixin class $JsModuleCopyWith<$Res> {
  factory $JsModuleCopyWith(JsModule value, $Res Function(JsModule) _then) =
      _$JsModuleCopyWithImpl;
  @useResult
  $Res call({String name, JsCode source});

  $JsCodeCopyWith<$Res> get source;
}

/// @nodoc
class _$JsModuleCopyWithImpl<$Res> implements $JsModuleCopyWith<$Res> {
  _$JsModuleCopyWithImpl(this._self, this._then);

  final JsModule _self;
  final $Res Function(JsModule) _then;

  /// Create a copy of JsModule
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? source = null,
  }) {
    return _then(_self.copyWith(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      source: null == source
          ? _self.source
          : source // ignore: cast_nullable_to_non_nullable
              as JsCode,
    ));
  }

  /// Create a copy of JsModule
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JsCodeCopyWith<$Res> get source {
    return $JsCodeCopyWith<$Res>(_self.source, (value) {
      return _then(_self.copyWith(source: value));
    });
  }
}

/// Adds pattern-matching-related methods to [JsModule].
extension JsModulePatterns on JsModule {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_JsModule value)? raw,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JsModule() when raw != null:
        return raw(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_JsModule value) raw,
  }) {
    final _that = this;
    switch (_that) {
      case _JsModule():
        return raw(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_JsModule value)? raw,
  }) {
    final _that = this;
    switch (_that) {
      case _JsModule() when raw != null:
        return raw(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String name, JsCode source)? raw,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JsModule() when raw != null:
        return raw(_that.name, _that.source);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String name, JsCode source) raw,
  }) {
    final _that = this;
    switch (_that) {
      case _JsModule():
        return raw(_that.name, _that.source);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String name, JsCode source)? raw,
  }) {
    final _that = this;
    switch (_that) {
      case _JsModule() when raw != null:
        return raw(_that.name, _that.source);
      case _:
        return null;
    }
  }
}

/// @nodoc

class _JsModule extends JsModule {
  const _JsModule({required this.name, required this.source}) : super._();

  @override
  final String name;
  @override
  final JsCode source;

  /// Create a copy of JsModule
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$JsModuleCopyWith<_JsModule> get copyWith =>
      __$JsModuleCopyWithImpl<_JsModule>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _JsModule &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.source, source) || other.source == source));
  }

  @override
  int get hashCode => Object.hash(runtimeType, name, source);

  @override
  String toString() {
    return 'JsModule.raw(name: $name, source: $source)';
  }
}

/// @nodoc
abstract mixin class _$JsModuleCopyWith<$Res>
    implements $JsModuleCopyWith<$Res> {
  factory _$JsModuleCopyWith(_JsModule value, $Res Function(_JsModule) _then) =
      __$JsModuleCopyWithImpl;
  @override
  @useResult
  $Res call({String name, JsCode source});

  @override
  $JsCodeCopyWith<$Res> get source;
}

/// @nodoc
class __$JsModuleCopyWithImpl<$Res> implements _$JsModuleCopyWith<$Res> {
  __$JsModuleCopyWithImpl(this._self, this._then);

  final _JsModule _self;
  final $Res Function(_JsModule) _then;

  /// Create a copy of JsModule
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = null,
    Object? source = null,
  }) {
    return _then(_JsModule(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      source: null == source
          ? _self.source
          : source // ignore: cast_nullable_to_non_nullable
              as JsCode,
    ));
  }

  /// Create a copy of JsModule
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JsCodeCopyWith<$Res> get source {
    return $JsCodeCopyWith<$Res>(_self.source, (value) {
      return _then(_self.copyWith(source: value));
    });
  }
}

// dart format on
