// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'runtime.dart';
import 'source.dart';
import 'value.dart';
part 'engine.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `declare_module`, `handle_action`, `new_bridge_call`, `register_fjs`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JsEngineCore>>
abstract class JsEngineCore implements RustOpaqueInterface {
  /// Returns the context.
  JsAsyncContext get context;

  /// Disposes the engine.
  @override
  Future<void> dispose();

  /// Returns whether the engine is disposed.
  bool get disposed;

  /// Executes an action.
  Future<void> exec({required JsAction action});

  /// Creates a new engine core.
  factory JsEngineCore({required JsAsyncContext context}) =>
      LibFjs.instance.api.crateApiEngineJsEngineCoreNew(context: context);

  /// Returns whether the engine is running.
  bool get running;

  /// Starts the engine event loop.
  Future<void> start(
      {required FutureOr<JsCallbackResult> Function(JsCallback) bridge});
}

@freezed
sealed class JsAction with _$JsAction {
  const JsAction._();

  /// Evaluate JavaScript code.
  const factory JsAction.eval({
    required int id,
    required JsCode source,
    JsEvalOptions? options,
  }) = JsAction_Eval;

  /// Declare a new module.
  const factory JsAction.declareNewModule({
    required int id,
    required JsModule module,
  }) = JsAction_DeclareNewModule;

  /// Declare multiple modules.
  const factory JsAction.declareNewModules({
    required int id,
    required List<JsModule> modules,
  }) = JsAction_DeclareNewModules;

  /// Clear all dynamic modules.
  const factory JsAction.clearNewModules({
    required int id,
  }) = JsAction_ClearNewModules;

  /// Evaluate a module.
  const factory JsAction.evaluateModule({
    required int id,
    required JsModule module,
  }) = JsAction_EvaluateModule;

  /// Get all declared module names.
  const factory JsAction.getDeclaredModules({
    required int id,
  }) = JsAction_GetDeclaredModules;

  /// Check if a module is declared.
  const factory JsAction.isModuleDeclared({
    required int id,
    required String moduleName,
  }) = JsAction_IsModuleDeclared;

  /// Call a function in a module.
  const factory JsAction.callFunction({
    required int id,
    required String module,
    required String method,
    List<JsValue>? params,
  }) = JsAction_CallFunction;
}

/// Result of a JavaScript action execution.
@freezed
sealed class JsActionResult with _$JsActionResult {
  const factory JsActionResult({
    required int id,
    required JsResult result,
  }) = _JsActionResult;
}

@freezed
sealed class JsCallback with _$JsCallback {
  const JsCallback._();

  /// Engine has been initialized.
  const factory JsCallback.initialized() = JsCallback_Initialized;

  /// Action execution result.
  const factory JsCallback.handler(
    JsActionResult field0,
  ) = JsCallback_Handler;

  /// Bridge call from JavaScript.
  const factory JsCallback.bridge(
    JsValue field0,
  ) = JsCallback_Bridge;
}

@freezed
sealed class JsCallbackResult with _$JsCallbackResult {
  const JsCallbackResult._();

  /// Initialization acknowledged.
  const factory JsCallbackResult.initialized() = JsCallbackResult_Initialized;

  /// Handler acknowledged.
  const factory JsCallbackResult.handler() = JsCallbackResult_Handler;

  /// Bridge call result.
  const factory JsCallbackResult.bridge(
    JsResult field0,
  ) = JsCallbackResult_Bridge;
}
