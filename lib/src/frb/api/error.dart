// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'value.dart';
part 'error.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `bridge`, `cancelled`, `context`, `conversion`, `engine`, `err`, `generic`, `io`, `is_err`, `is_ok`, `map_err`, `map`, `memory_limit`, `module`, `ok`, `promise`, `reference`, `runtime`, `storage`, `syntax`, `timeout`, `type_error`

@freezed
sealed class JsError with _$JsError {
  const JsError._();

  /// Promise-related errors (async operation failures)
  const factory JsError.promise(
    String field0,
  ) = JsError_Promise;

  /// Module-related errors (import/export failures)
  const factory JsError.module({
    /// Optional module name where the error occurred
    String? module,

    /// Optional method name where the error occurred
    String? method,

    /// Error message
    required String message,
  }) = JsError_Module;

  /// Context attachment errors (global object setup failures)
  const factory JsError.context(
    String field0,
  ) = JsError_Context;

  /// Storage initialization errors (dynamic module storage failures)
  const factory JsError.storage(
    String field0,
  ) = JsError_Storage;

  /// File I/O errors (file reading failures)
  const factory JsError.io({
    /// Optional file path where the error occurred
    String? path,

    /// Error message
    required String message,
  }) = JsError_Io;

  /// JavaScript runtime errors from QuickJS engine
  const factory JsError.runtime(
    String field0,
  ) = JsError_Runtime;

  /// Generic catch-all errors
  const factory JsError.generic(
    String field0,
  ) = JsError_Generic;

  /// Engine lifecycle errors
  const factory JsError.engine(
    String field0,
  ) = JsError_Engine;

  /// Bridge communication errors
  const factory JsError.bridge(
    String field0,
  ) = JsError_Bridge;

  /// Type conversion errors
  const factory JsError.conversion({
    /// The source type
    required String from,

    /// The target type
    required String to,

    /// Error message
    required String message,
  }) = JsError_Conversion;

  /// Timeout errors
  const factory JsError.timeout({
    /// Operation that timed out
    required String operation,

    /// Timeout duration in milliseconds
    required BigInt timeoutMs,
  }) = JsError_Timeout;

  /// Memory limit exceeded errors
  const factory JsError.memoryLimit({
    /// Current memory usage in bytes
    required BigInt current,

    /// Memory limit in bytes
    required BigInt limit,
  }) = JsError_MemoryLimit;

  /// Stack overflow errors
  const factory JsError.stackOverflow(
    String field0,
  ) = JsError_StackOverflow;

  /// Syntax errors in JavaScript code
  const factory JsError.syntax({
    /// Line number where the error occurred
    int? line,

    /// Column number where the error occurred
    int? column,

    /// Error message
    required String message,
  }) = JsError_Syntax;

  /// Reference errors (undefined variables, etc.)
  const factory JsError.reference(
    String field0,
  ) = JsError_Reference;

  /// Type errors in JavaScript
  const factory JsError.type(
    String field0,
  ) = JsError_Type;

  /// Cancelled operation errors
  const factory JsError.cancelled(
    String field0,
  ) = JsError_Cancelled;

  /// Returns the error code for this error type.
  String code() => LibFjs.instance.api.crateApiErrorJsErrorCode(
        that: this,
      );

  /// Returns whether this error is recoverable.
  bool isRecoverable() => LibFjs.instance.api.crateApiErrorJsErrorIsRecoverable(
        that: this,
      );

  /// Converts the error to a string representation.
  @override
  String toString() => LibFjs.instance.api.crateApiErrorJsErrorToString(
        that: this,
      );
}

@freezed
sealed class JsResult with _$JsResult {
  const JsResult._();

  /// Successful execution result
  const factory JsResult.ok(
    JsValue field0,
  ) = JsResult_Ok;

  /// Error during execution
  const factory JsResult.err(
    JsError field0,
  ) = JsResult_Err;

  bool get isOk => this is JsResult_Ok;
  bool get isErr => this is JsResult_Err;
  JsValue get ok => (this as JsResult_Ok).field0;
  JsError get err => (this as JsResult_Err).field0;
}
