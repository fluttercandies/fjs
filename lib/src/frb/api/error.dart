// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'value.dart';
part 'error.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `bridge`, `cancelled`, `context`, `conversion`, `engine`, `err`, `generic`, `into_result`, `io`, `is_err`, `is_ok`, `map_err`, `map`, `memory_limit`, `module`, `ok`, `promise`, `reference`, `runtime`, `storage`, `syntax`, `timeout`, `type_error`

@freezed
sealed class JsError with _$JsError {
  const JsError._();

  /// Promise-related errors (async operation failures)
  const factory JsError.promise(
    String field0,
  ) = JsError_Promise;

  /// Module-related errors (import/export failures)
  const factory JsError.module({
    /// Optional module name where the error occurred
    String? module,

    /// Optional method name where the error occurred
    String? method,

    /// Error message
    required String message,
  }) = JsError_Module;

  /// Context attachment errors (global object setup failures)
  const factory JsError.context(
    String field0,
  ) = JsError_Context;

  /// Storage initialization errors (dynamic module storage failures)
  const factory JsError.storage(
    String field0,
  ) = JsError_Storage;

  /// File I/O errors (file reading failures)
  const factory JsError.io({
    /// Optional file path where the error occurred
    String? path,

    /// Error message
    required String message,
  }) = JsError_Io;

  /// JavaScript runtime errors from QuickJS engine
  const factory JsError.runtime(
    String field0,
  ) = JsError_Runtime;

  /// Generic catch-all errors
  const factory JsError.generic(
    String field0,
  ) = JsError_Generic;

  /// Engine lifecycle errors
  const factory JsError.engine(
    String field0,
  ) = JsError_Engine;

  /// Bridge communication errors
  const factory JsError.bridge(
    String field0,
  ) = JsError_Bridge;

  /// Type conversion errors
  const factory JsError.conversion({
    /// The source type
    required String from,

    /// The target type
    required String to,

    /// Error message
    required String message,
  }) = JsError_Conversion;

  /// Timeout errors
  const factory JsError.timeout({
    /// Operation that timed out
    required String operation,

    /// Timeout duration in milliseconds
    required BigInt timeoutMs,
  }) = JsError_Timeout;

  /// Memory limit exceeded errors
  const factory JsError.memoryLimit({
    /// Current memory usage in bytes
    required BigInt current,

    /// Memory limit in bytes
    required BigInt limit,
  }) = JsError_MemoryLimit;

  /// Stack overflow errors
  const factory JsError.stackOverflow(
    String field0,
  ) = JsError_StackOverflow;

  /// Syntax errors in JavaScript code
  const factory JsError.syntax({
    /// Line number where the error occurred
    int? line,

    /// Column number where the error occurred
    int? column,

    /// Error message
    required String message,
  }) = JsError_Syntax;

  /// Reference errors (undefined variables, etc.)
  const factory JsError.reference(
    String field0,
  ) = JsError_Reference;

  /// Type errors in JavaScript
  const factory JsError.type(
    String field0,
  ) = JsError_Type;

  /// Cancelled operation errors
  const factory JsError.cancelled(
    String field0,
  ) = JsError_Cancelled;

  /// Returns the error code for this error type.
  ///
  /// The error code is a constant string identifier for the error category,
  /// useful for programmatic error handling.
  ///
  /// ## Returns
  ///
  /// The error code as a string (e.g., "PROMISE_ERROR", "RUNTIME_ERROR")
  ///
  /// ## Example
  ///
  /// ```dart
  /// try {
  ///   final result = await context.eval(code: 'invalid');
  /// } catch (e) {
  ///   if (e is JsError) {
  ///     switch (e.code()) {
  ///       case 'SYNTAX_ERROR':
  ///         print('Syntax error in code');
  ///         break;
  ///       case 'RUNTIME_ERROR':
  ///         print('Runtime error occurred');
  ///         break;
  ///       default:
  ///         print('Other error: ${e.code()}');
  ///     }
  ///   }
  /// }
  /// ```
  String code() => LibFjs.instance.api.crateApiErrorJsErrorCode(
        that: this,
      );

  /// Returns whether this error is recoverable.
  ///
  /// Recoverable errors are typically transient issues (like network errors,
  /// parse errors, or timeout errors) that might succeed if retried.
  /// Non-recoverable errors indicate serious issues (like context failures,
  /// memory limits, or stack overflows) that generally cannot be fixed
  /// without changing the execution environment.
  ///
  /// ## Returns
  ///
  /// `true` if the error is recoverable, `false` otherwise
  ///
  /// ## Example
  ///
  /// ```dart
  /// try {
  ///   final result = await context.eval(code: code);
  /// } catch (e) {
  ///   if (e is JsError && e.isRecoverable()) {
  ///     // Can retry the operation
  ///     await Future.delayed(Duration(seconds: 1));
  ///     await context.eval(code: code);
  ///   } else {
  ///     // Fatal error, cannot recover
  ///     rethrow;
  ///   }
  /// }
  /// ```
  bool isRecoverable() => LibFjs.instance.api.crateApiErrorJsErrorIsRecoverable(
        that: this,
      );

  /// Converts the error to a string representation.
  ///
  /// ## Returns
  ///
  /// A formatted string describing the error
  @override
  String toString() => LibFjs.instance.api.crateApiErrorJsErrorToString(
        that: this,
      );
}

@freezed
sealed class JsResult with _$JsResult {
  const JsResult._();

  /// Successful execution result containing the value
  const factory JsResult.ok(
    JsValue field0,
  ) = JsResult_Ok;

  /// Error during execution containing the error details
  const factory JsResult.err(
    JsError field0,
  ) = JsResult_Err;

  bool get isOk => this is JsResult_Ok;
  bool get isErr => this is JsResult_Err;
  JsValue get ok => (this as JsResult_Ok).field0;
  JsError get err => (this as JsResult_Err).field0;
}
