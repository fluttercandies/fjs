// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'value.dart';
part 'js.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `from_promise_result`, `into`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `cmp`, `eq`, `fmt`, `fmt`, `hash`, `partial_cmp`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AsyncContext>>
abstract class AsyncContext implements RustOpaqueInterface {
  Future<EvalResult> eval({required String code});

  Future<EvalResult> evalFile({required String path});

  Future<EvalResult> evalFileWithOptions(
      {required String path, required EvalOptions options});

  Future<EvalResult> evalFunction(
      {required String module, required String method, List<JsValue>? params});

  Future<EvalResult> evalWithOptions(
      {required String code, required EvalOptions options});

  static Future<AsyncContext> full({required AsyncRuntime rt}) =>
      LibFjs.instance.api.crateApiJsAsyncContextFull(rt: rt);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AsyncRuntime>>
abstract class AsyncRuntime implements RustOpaqueInterface {
  Future<bool> executePendingJob();

  Future<void> idle();

  Future<bool> isJobPending();

  Future<MemoryUsage> memoryUsage();

  factory AsyncRuntime() => LibFjs.instance.api.crateApiJsAsyncRuntimeNew();

  Future<void> runGc();

  Future<void> setGcThreshold({required BigInt threshold});

  Future<void> setMaxStackSize({required BigInt limit});

  Future<void> setMemoryLimit({required BigInt limit});

  Future<void> setModules({required List<JsModule> modules});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryUsage>>
abstract class MemoryUsage implements RustOpaqueInterface {}

@freezed
@immutable
class EvalOptions with _$EvalOptions {
  const EvalOptions._();
  const factory EvalOptions.raw({
    required bool global,
    required bool strict,
    required bool backtraceBarrier,
  }) = _EvalOptions;
  factory EvalOptions() => LibFjs.instance.api.crateApiJsEvalOptionsNew();
}

@freezed
sealed class EvalResult with _$EvalResult {
  const EvalResult._();

  const factory EvalResult.ok(
    JsValue field0,
  ) = EvalResult_Ok;
  const factory EvalResult.err(
    String field0,
  ) = EvalResult_Err;

  bool get isOk => this is EvalResult_Ok;
  bool get isErr => this is EvalResult_Err;
  JsValue get ok => (this as EvalResult_Ok).field0;
  String get err => (this as EvalResult_Err).field0;
}

@freezed
sealed class JsModule with _$JsModule {
  const JsModule._();

  const factory JsModule.code(
    String field0,
    String field1,
  ) = JsModule_Code;
  const factory JsModule.path(
    String field0,
    String field1,
  ) = JsModule_Path;

  static JsModule fromCode({required String module, required String code}) =>
      LibFjs.instance.api
          .crateApiJsJsModuleFromCode(module: module, code: code);

  static JsModule fromPath({required String module, required String path}) =>
      LibFjs.instance.api
          .crateApiJsJsModuleFromPath(module: module, path: path);

  factory JsModule({required String module, String? code, String? path}) =>
      LibFjs.instance.api
          .crateApiJsJsModuleNew(module: module, code: code, path: path);
}
