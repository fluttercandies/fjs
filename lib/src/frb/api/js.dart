// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'value.dart';
part 'js.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `from_promise_result`, `from_result`, `get_raw_source_code`, `init_async`, `init`, `new_bridge_call`, `register_fjs`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `cmp`, `cmp`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `hash`, `hash`, `partial_cmp`, `partial_cmp`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `default`, `default`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JsAsyncContext>>
abstract class JsAsyncContext implements RustOpaqueInterface {
  Future<JsResult> eval({required String code});

  Future<JsResult> evalFile({required String path});

  Future<JsResult> evalFileWithOptions(
      {required String path, required JsEvalOptions options});

  Future<JsResult> evalFunction(
      {required String module, required String method, List<JsValue>? params});

  Future<JsResult> evalWithOptions(
      {required String code, required JsEvalOptions options});

  static Future<JsAsyncContext> from({required JsAsyncRuntime rt}) =>
      LibFjs.instance.api.crateApiJsJsAsyncContextFrom(rt: rt);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JsAsyncRuntime>>
abstract class JsAsyncRuntime implements RustOpaqueInterface {
  Future<bool> executePendingJob();

  Future<void> idle();

  Future<bool> isJobPending();

  Future<MemoryUsage> memoryUsage();

  factory JsAsyncRuntime() => LibFjs.instance.api.crateApiJsJsAsyncRuntimeNew();

  Future<void> runGc();

  Future<void> setGcThreshold({required BigInt threshold});

  Future<void> setInfo({required String info});

  Future<void> setMaxStackSize({required BigInt limit});

  Future<void> setMemoryLimit({required BigInt limit});

  Future<void> setModules({required List<JsModule> modules});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JsContext>>
abstract class JsContext implements RustOpaqueInterface {
  JsResult eval({required String code});

  JsResult evalFile({required String path});

  JsResult evalFileWithOptions(
      {required String path, required JsEvalOptions options});

  JsResult evalWithOptions(
      {required String code, required JsEvalOptions options});

  factory JsContext({required JsRuntime rt}) =>
      LibFjs.instance.api.crateApiJsJsContextNew(rt: rt);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JsEngineCore>>
abstract class JsEngineCore implements RustOpaqueInterface {
  JsAsyncContext get context;

  @override
  Future<void> dispose();

  bool get disposed;

  Future<void> exec({required JsAction action});

  factory JsEngineCore({required JsAsyncContext context}) =>
      LibFjs.instance.api.crateApiJsJsEngineCoreNew(context: context);

  bool get running;

  Future<void> start(
      {required FutureOr<JsCallbackResult> Function(JsCallback) bridge});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JsRuntime>>
abstract class JsRuntime implements RustOpaqueInterface {
  bool executePendingJob();

  bool isJobPending();

  MemoryUsage memoryUsage();

  factory JsRuntime() => LibFjs.instance.api.crateApiJsJsRuntimeNew();

  void runGc();

  void setDumpFlags({required BigInt flags});

  void setGcThreshold({required BigInt threshold});

  void setInfo({required String info});

  void setMaxStackSize({required BigInt limit});

  void setMemoryLimit({required BigInt limit});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryUsage>>
abstract class MemoryUsage implements RustOpaqueInterface {
  PlatformInt64 get arrayCount;

  PlatformInt64 get atomCount;

  PlatformInt64 get atomSize;

  PlatformInt64 get binaryObjectCount;

  PlatformInt64 get binaryObjectSize;

  PlatformInt64 get cFuncCount;

  PlatformInt64 get fastArrayCount;

  PlatformInt64 get fastArrayElements;

  PlatformInt64 get jsFuncCodeSize;

  PlatformInt64 get jsFuncCount;

  PlatformInt64 get jsFuncPc2LineCount;

  PlatformInt64 get jsFuncPc2LineSize;

  PlatformInt64 get jsFuncSize;

  PlatformInt64 get mallocCount;

  PlatformInt64 get mallocLimit;

  PlatformInt64 get mallocSize;

  PlatformInt64 get memoryUsedCount;

  PlatformInt64 get memoryUsedSize;

  PlatformInt64 get objCount;

  PlatformInt64 get objSize;

  PlatformInt64 get propCount;

  PlatformInt64 get propSize;

  PlatformInt64 get shapeCount;

  PlatformInt64 get shapeSize;

  PlatformInt64 get strCount;

  PlatformInt64 get strSize;
}

@freezed
sealed class JsAction with _$JsAction {
  const JsAction._();

  const factory JsAction.eval({
    required int id,
    required JsCode source,
    JsEvalOptions? options,
  }) = JsAction_Eval;
  const factory JsAction.declareModule({
    required int id,
    required JsModule module,
  }) = JsAction_DeclareModule;
  const factory JsAction.evaluateModule({
    required int id,
    required JsModule module,
  }) = JsAction_EvaluateModule;
  const factory JsAction.importModule({
    required int id,
    required String specifier,
  }) = JsAction_ImportModule;
  const factory JsAction.enableBuiltinModule({
    required int id,
    required JsBuiltinOptions builtinOptions,
  }) = JsAction_EnableBuiltinModule;
}

@freezed
sealed class JsActionResult with _$JsActionResult {
  const factory JsActionResult({
    required int id,
    required JsResult result,
  }) = _JsActionResult;
}

@freezed
sealed class JsBuiltinOptions with _$JsBuiltinOptions {
  const factory JsBuiltinOptions({
    bool? fetch,
    bool? console,
    bool? buffer,
    bool? stringDecoder,
    bool? timers,
    bool? stream,
    bool? crypto,
    bool? abort,
    bool? url,
    bool? events,
  }) = _JsBuiltinOptions;

  const JsBuiltinOptions._();
  factory JsBuiltinOptions.from(Set<String> enableModules) {
    return JsBuiltinOptions(
      fetch: enableModules.contains('fetch'),
      console: enableModules.contains('console'),
      buffer: enableModules.contains('buffer'),
      stringDecoder: enableModules.contains('string_decoder'),
      timers: enableModules.contains('timers'),
      stream: enableModules.contains('stream'),
      crypto: enableModules.contains('crypto'),
      abort: enableModules.contains('abort_controller'),
      url: enableModules.contains('url'),
      events: enableModules.contains('events'),
    );
  }
  Set<String> get enabledModules {
    final modules = <String>{};
    if (fetch == true) modules.add('fetch');
    if (console == true) modules.add('console');
    if (buffer == true) modules.add('buffer');
    if (stringDecoder == true) modules.add('string_decoder');
    if (timers == true) modules.add('timers');
    if (stream == true) modules.add('stream');
    if (crypto == true) modules.add('crypto');
    if (abort == true) modules.add('abort_controller');
    if (url == true) modules.add('url');
    if (events == true) modules.add('events');
    return modules;
  }
}

@freezed
sealed class JsCallback with _$JsCallback {
  const JsCallback._();

  const factory JsCallback.initialized() = JsCallback_Initialized;
  const factory JsCallback.handler(
    JsActionResult field0,
  ) = JsCallback_Handler;
  const factory JsCallback.bridge(
    JsValue field0,
  ) = JsCallback_Bridge;
}

@freezed
sealed class JsCallbackResult with _$JsCallbackResult {
  const JsCallbackResult._();

  const factory JsCallbackResult.initialized() = JsCallbackResult_Initialized;
  const factory JsCallbackResult.handler() = JsCallbackResult_Handler;
  const factory JsCallbackResult.bridge(
    JsResult field0,
  ) = JsCallbackResult_Bridge;
}

@freezed
sealed class JsCode with _$JsCode {
  const JsCode._();

  const factory JsCode.code(
    String field0,
  ) = JsCode_Code;
  const factory JsCode.path(
    String field0,
  ) = JsCode_Path;
}

@freezed
sealed class JsEvalOptions with _$JsEvalOptions {
  const JsEvalOptions._();
  const factory JsEvalOptions.raw({
    bool? global,
    bool? strict,
    bool? backtraceBarrier,
    bool? promise,
    JsBuiltinOptions? builtinOptions,
  }) = _JsEvalOptions;
  factory JsEvalOptions(
          {bool? global,
          bool? strict,
          bool? backtraceBarrier,
          bool? promise,
          JsBuiltinOptions? builtinOptions}) =>
      LibFjs.instance.api.crateApiJsJsEvalOptionsNew(
          global: global,
          strict: strict,
          backtraceBarrier: backtraceBarrier,
          promise: promise,
          builtinOptions: builtinOptions);
}

@freezed
sealed class JsModule with _$JsModule {
  const JsModule._();
  const factory JsModule.raw({
    required String name,
    required JsCode source,
  }) = _JsModule;
  static JsModule code({required String module, required String code}) =>
      LibFjs.instance.api.crateApiJsJsModuleCode(module: module, code: code);

  factory JsModule({required String name, required JsCode source}) =>
      LibFjs.instance.api.crateApiJsJsModuleNew(name: name, source: source);

  static JsModule path({required String module, required String path}) =>
      LibFjs.instance.api.crateApiJsJsModulePath(module: module, path: path);
}

@freezed
sealed class JsResult with _$JsResult {
  const JsResult._();

  const factory JsResult.ok(
    JsValue field0,
  ) = JsResult_Ok;
  const factory JsResult.err(
    String field0,
  ) = JsResult_Err;

  bool get isOk => this is JsResult_Ok;
  bool get isErr => this is JsResult_Err;
  JsValue get ok => (this as JsResult_Ok).field0;
  String get err => (this as JsResult_Err).field0;
}
