// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'source.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `cmp`, `cmp`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `hash`, `hash`, `partial_cmp`, `partial_cmp`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `as_path`, `bytes`, `bytes`, `code`, `code`, `get_raw_source_code_sync`, `get_raw_source_code`, `path`, `path`

/// Options for configuring builtin Node.js modules.
///
/// This struct provides fine-grained control over which Node.js
/// compatibility modules should be available in the runtime.
@freezed
sealed class JsBuiltinOptions with _$JsBuiltinOptions {
  const JsBuiltinOptions._();
  const factory JsBuiltinOptions({
    bool? abort,
    bool? assert_,
    bool? asyncHooks,
    bool? buffer,
    bool? childProcess,
    bool? console,
    bool? crypto,
    bool? dns,
    bool? events,
    bool? exceptions,
    bool? fetch,
    bool? fs,
    bool? navigator,
    bool? net,
    bool? os,
    bool? path,
    bool? perfHooks,
    bool? process,
    bool? streamWeb,
    bool? stringDecoder,
    bool? timers,
    bool? tty,
    bool? url,
    bool? util,
    bool? zlib,
    bool? json,
  }) = _JsBuiltinOptions;

  /// Creates builtin options with all modules enabled.
  static JsBuiltinOptions all() =>
      LibFjs.instance.api.crateApiSourceJsBuiltinOptionsAll();

  static Future<JsBuiltinOptions> default_() =>
      LibFjs.instance.api.crateApiSourceJsBuiltinOptionsDefault();

  /// Creates builtin options with essential modules only.
  /// Includes: console, timers, buffer, util, json
  static JsBuiltinOptions essential() =>
      LibFjs.instance.api.crateApiSourceJsBuiltinOptionsEssential();

  /// Creates builtin options for Node.js-like environment.
  /// Includes most modules except OS-specific ones.
  static JsBuiltinOptions node() =>
      LibFjs.instance.api.crateApiSourceJsBuiltinOptionsNode();

  /// Creates builtin options with no modules enabled.
  static JsBuiltinOptions none() =>
      LibFjs.instance.api.crateApiSourceJsBuiltinOptionsNone();

  /// Creates builtin options for web-like environment.
  /// Includes: console, timers, fetch, url, crypto, stream_web
  static JsBuiltinOptions web() =>
      LibFjs.instance.api.crateApiSourceJsBuiltinOptionsWeb();
}

@freezed
sealed class JsCode with _$JsCode {
  const JsCode._();

  /// Inline JavaScript code as a string
  const factory JsCode.code(
    String field0,
  ) = JsCode_Code;

  /// File path containing JavaScript code
  const factory JsCode.path(
    String field0,
  ) = JsCode_Path;

  /// Raw bytes containing JavaScript code (UTF-8 encoded)
  const factory JsCode.bytes(
    Uint8List field0,
  ) = JsCode_Bytes;

  /// Returns true if this is a Bytes variant.
  bool isBytes() => LibFjs.instance.api.crateApiSourceJsCodeIsBytes(
        that: this,
      );

  /// Returns true if this is a Code variant.
  bool isCode() => LibFjs.instance.api.crateApiSourceJsCodeIsCode(
        that: this,
      );

  /// Returns true if this is a Path variant.
  bool isPath() => LibFjs.instance.api.crateApiSourceJsCodeIsPath(
        that: this,
      );
}

/// Options for JavaScript code evaluation.
///
/// This struct provides configuration options for how JavaScript
/// code should be executed and evaluated.
@freezed
sealed class JsEvalOptions with _$JsEvalOptions {
  const JsEvalOptions._();
  const factory JsEvalOptions.raw({
    bool? global,
    bool? strict,
    bool? backtraceBarrier,
    bool? promise,
  }) = _JsEvalOptions;
  static Future<JsEvalOptions> default_() =>
      LibFjs.instance.api.crateApiSourceJsEvalOptionsDefault();

  /// Creates options with default values (global scope, strict mode).
  static JsEvalOptions defaults() =>
      LibFjs.instance.api.crateApiSourceJsEvalOptionsDefaults();

  /// Creates options for module evaluation.
  static JsEvalOptions module() =>
      LibFjs.instance.api.crateApiSourceJsEvalOptionsModule();

  /// Creates new evaluation options with the specified parameters.
  factory JsEvalOptions(
          {bool? global,
          bool? strict,
          bool? backtraceBarrier,
          bool? promise}) =>
      LibFjs.instance.api.crateApiSourceJsEvalOptionsNew(
          global: global,
          strict: strict,
          backtraceBarrier: backtraceBarrier,
          promise: promise);

  /// Creates options with promise support enabled.
  static JsEvalOptions withPromise() =>
      LibFjs.instance.api.crateApiSourceJsEvalOptionsWithPromise();
}

/// Represents a JavaScript module.
///
/// This struct defines a module with a name and source code,
/// which can be loaded and executed in the JavaScript runtime.
@freezed
sealed class JsModule with _$JsModule {
  const JsModule._();
  const factory JsModule.raw({
    required String name,
    required JsCode source,
  }) = _JsModule;

  /// Creates a module from raw bytes.
  static JsModule fromBytes(
          {required String module, required List<int> bytes}) =>
      LibFjs.instance.api
          .crateApiSourceJsModuleFromBytes(module: module, bytes: bytes);

  /// Creates a module from inline code string.
  static JsModule fromCode({required String module, required String code}) =>
      LibFjs.instance.api
          .crateApiSourceJsModuleFromCode(module: module, code: code);

  /// Creates a module from a file path string.
  static JsModule fromPath({required String module, required String path}) =>
      LibFjs.instance.api
          .crateApiSourceJsModuleFromPath(module: module, path: path);

  /// Creates a new module with the given name and source.
  factory JsModule({required String name, required JsCode source}) =>
      LibFjs.instance.api.crateApiSourceJsModuleNew(name: name, source: source);
}
