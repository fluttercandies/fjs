// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'source.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `cmp`, `cmp`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `hash`, `hash`, `partial_cmp`, `partial_cmp`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `as_path`, `bytes`, `code`, `get_raw_source_code_sync`, `get_raw_source_code`, `path`

/// Options for configuring builtin Node.js modules.
///
/// This struct provides fine-grained control over which Node.js
/// compatibility modules should be available in the runtime.
///
/// ## Example
///
/// ```dart
/// // Enable all builtins
/// final opts1 = JsBuiltinOptions.all();
///
/// // Enable only essential modules
/// final opts2 = JsBuiltinOptions.essential();
///
/// // Web-like environment
/// final opts3 = JsBuiltinOptions.web();
///
/// // Custom configuration
/// final opts4 = JsBuiltinOptions(
///   console: Some(true),
///   timers: Some(true),
///   // ... other options
/// );
/// ```
@freezed
sealed class JsBuiltinOptions with _$JsBuiltinOptions {
  const JsBuiltinOptions._();
  const factory JsBuiltinOptions({
    bool? abort,
    bool? assert_,
    bool? asyncHooks,
    bool? buffer,
    bool? childProcess,
    bool? console,
    bool? crypto,
    bool? dns,
    bool? events,
    bool? exceptions,
    bool? fetch,
    bool? fs,
    bool? navigator,
    bool? net,
    bool? os,
    bool? path,
    bool? perfHooks,
    bool? process,
    bool? streamWeb,
    bool? stringDecoder,
    bool? timers,
    bool? tty,
    bool? url,
    bool? util,
    bool? zlib,
    bool? json,
  }) = _JsBuiltinOptions;

  /// Creates builtin options with all modules enabled.
  ///
  /// This enables every available Node.js-compatible builtin module,
  /// providing maximum compatibility at the cost of larger binary size.
  ///
  /// ## Returns
  ///
  /// A `JsBuiltinOptions` instance with all modules enabled
  ///
  /// ## Example
  ///
  /// ```dart
  /// final opts = JsBuiltinOptions.all();
  /// final runtime = await JsAsyncRuntime.withOptions(builtin: opts);
  /// ```
  static JsBuiltinOptions all() =>
      LibFjs.instance.api.crateApiSourceJsBuiltinOptionsAll();

  static Future<JsBuiltinOptions> default_() =>
      LibFjs.instance.api.crateApiSourceJsBuiltinOptionsDefault();

  /// Creates builtin options with essential modules only.
  ///
  /// Enables only the most commonly needed modules: console, timers, buffer, util, json.
  /// This provides a good balance between functionality and binary size.
  ///
  /// ## Returns
  ///
  /// A `JsBuiltinOptions` instance with essential modules
  ///
  /// ## Example
  ///
  /// ```dart
  /// final opts = JsBuiltinOptions.essential();
  /// final runtime = await JsAsyncRuntime.withOptions(builtin: opts);
  /// ```
  static JsBuiltinOptions essential() =>
      LibFjs.instance.api.crateApiSourceJsBuiltinOptionsEssential();

  /// Creates builtin options for Node.js-like environment.
  ///
  /// Enables most Node.js-compatible modules except OS-specific ones.
  /// Suitable for server-side JavaScript applications.
  ///
  /// ## Returns
  ///
  /// A `JsBuiltinOptions` instance configured for Node.js-like environment
  ///
  /// ## Example
  ///
  /// ```dart
  /// final opts = JsBuiltinOptions.node();
  /// final runtime = await JsAsyncRuntime.withOptions(builtin: opts);
  /// ```
  static JsBuiltinOptions node() =>
      LibFjs.instance.api.crateApiSourceJsBuiltinOptionsNode();

  /// Creates builtin options with no modules enabled.
  ///
  /// Creates a minimal runtime without any builtin modules.
  /// Use this when you want complete control over which modules are available.
  ///
  /// ## Returns
  ///
  /// A `JsBuiltinOptions` instance with no modules enabled
  ///
  /// ## Example
  ///
  /// ```dart
  /// final opts = JsBuiltinOptions.none();
  /// final runtime = await JsAsyncRuntime.withOptions(builtin: opts);
  /// ```
  static JsBuiltinOptions none() =>
      LibFjs.instance.api.crateApiSourceJsBuiltinOptionsNone();

  /// Creates builtin options for web-like environment.
  ///
  /// Enables modules typically available in web browsers:
  /// console, timers, fetch, url, crypto, stream_web, navigator, exceptions, json.
  ///
  /// ## Returns
  ///
  /// A `JsBuiltinOptions` instance configured for web-like environment
  ///
  /// ## Example
  ///
  /// ```dart
  /// final opts = JsBuiltinOptions.web();
  /// final runtime = await JsAsyncRuntime.withOptions(builtin: opts);
  /// ```
  static JsBuiltinOptions web() =>
      LibFjs.instance.api.crateApiSourceJsBuiltinOptionsWeb();
}

@freezed
sealed class JsCode with _$JsCode {
  const JsCode._();

  /// Inline JavaScript code as a string
  const factory JsCode.code(
    String field0,
  ) = JsCode_Code;

  /// File path containing JavaScript code
  const factory JsCode.path(
    String field0,
  ) = JsCode_Path;

  /// Raw bytes containing JavaScript code (UTF-8 encoded)
  const factory JsCode.bytes(
    Uint8List field0,
  ) = JsCode_Bytes;

  /// Returns true if this is a Bytes variant.
  ///
  /// ## Returns
  ///
  /// `true` if this is a Bytes variant, `false` otherwise
  bool isBytes() => LibFjs.instance.api.crateApiSourceJsCodeIsBytes(
        that: this,
      );

  /// Returns true if this is a Code variant.
  ///
  /// ## Returns
  ///
  /// `true` if this is a Code variant, `false` otherwise
  bool isCode() => LibFjs.instance.api.crateApiSourceJsCodeIsCode(
        that: this,
      );

  /// Returns true if this is a Path variant.
  ///
  /// ## Returns
  ///
  /// `true` if this is a Path variant, `false` otherwise
  bool isPath() => LibFjs.instance.api.crateApiSourceJsCodeIsPath(
        that: this,
      );
}

/// Options for JavaScript code evaluation.
///
/// This struct provides configuration options for how JavaScript
/// code should be executed and evaluated.
///
/// ## Example
///
/// ```dart
/// // Default options
/// final opts1 = JsEvalOptions.defaults();
///
/// // With promise support
/// final opts2 = JsEvalOptions.withPromise();
///
/// // Custom options
/// final opts3 = JsEvalOptions(
///   global: true,
///   strict: true,
///   backtraceBarrier: false,
///   promise: true,
/// );
/// ```
@freezed
sealed class JsEvalOptions with _$JsEvalOptions {
  const JsEvalOptions._();
  const factory JsEvalOptions.raw({
    bool? global,
    bool? strict,
    bool? backtraceBarrier,
    bool? promise,
  }) = _JsEvalOptions;
  static Future<JsEvalOptions> default_() =>
      LibFjs.instance.api.crateApiSourceJsEvalOptionsDefault();

  /// Creates options with default values (global scope, strict mode).
  ///
  /// Default settings:
  /// - global: true
  /// - strict: true
  /// - backtrace_barrier: false
  /// - promise: false
  ///
  /// ## Returns
  ///
  /// A `JsEvalOptions` instance with default values
  ///
  /// ## Example
  ///
  /// ```dart
  /// final opts = JsEvalOptions.defaults();
  /// ```
  static JsEvalOptions defaults() =>
      LibFjs.instance.api.crateApiSourceJsEvalOptionsDefaults();

  /// Creates options for module evaluation.
  ///
  /// Module scope (not global), strict mode, with promise support.
  ///
  /// ## Returns
  ///
  /// A `JsEvalOptions` instance configured for modules
  static JsEvalOptions module() =>
      LibFjs.instance.api.crateApiSourceJsEvalOptionsModule();

  /// Creates new evaluation options with the specified parameters.
  ///
  /// ## Parameters
  ///
  /// - `global`: Whether to evaluate in global scope
  /// - `strict`: Whether to enforce strict mode
  /// - `backtraceBarrier`: Whether to create a backtrace barrier
  /// - `promise`: Whether to enable promise/async support
  ///
  /// ## Returns
  ///
  /// A new `JsEvalOptions` instance
  factory JsEvalOptions(
          {bool? global,
          bool? strict,
          bool? backtraceBarrier,
          bool? promise}) =>
      LibFjs.instance.api.crateApiSourceJsEvalOptionsNew(
          global: global,
          strict: strict,
          backtraceBarrier: backtraceBarrier,
          promise: promise);

  /// Creates options with promise support enabled.
  ///
  /// Enables top-level await and async/await support.
  ///
  /// ## Returns
  ///
  /// A `JsEvalOptions` instance with promise support
  ///
  /// ## Example
  ///
  /// ```dart
  /// final opts = JsEvalOptions.withPromise();
  /// ```
  static JsEvalOptions withPromise() =>
      LibFjs.instance.api.crateApiSourceJsEvalOptionsWithPromise();
}

/// Represents a JavaScript module.
///
/// This struct defines a module with a name and source code,
/// which can be loaded and executed in the JavaScript runtime.
///
/// ## Example
///
/// ```dart
/// // Create a module from inline code
/// final module = JsModule.code(
///   module: 'my-utils',
///   code: 'export const add = (a, b) => a + b;',
/// );
///
/// // Create a module from a file
/// final module2 = JsModule.path(
///   module: 'math',
///   path: '/path/to/math.js',
/// );
///
/// // Create a module from bytes
/// final module3 = JsModule.bytes(
///   module: 'binary-utils',
///   bytes: utf8.encode('export const VERSION = "1.0";'),
/// );
/// ```
@freezed
sealed class JsModule with _$JsModule {
  const JsModule._();
  const factory JsModule.raw({
    required String name,
    required JsCode source,
  }) = _JsModule;

  /// Creates a module from raw bytes.
  static JsModule bytes({required String module, required List<int> bytes}) =>
      LibFjs.instance.api
          .crateApiSourceJsModuleBytes(module: module, bytes: bytes);

  /// Creates a module from inline code.
  static JsModule code({required String module, required String code}) =>
      LibFjs.instance.api
          .crateApiSourceJsModuleCode(module: module, code: code);

  /// Creates a new module with the given name and source.
  ///
  /// ## Parameters
  ///
  /// - `name`: The module name
  /// - `source`: The source code
  ///
  /// ## Returns
  ///
  /// A new `JsModule` instance
  factory JsModule({required String name, required JsCode source}) =>
      LibFjs.instance.api.crateApiSourceJsModuleNew(name: name, source: source);

  /// Creates a module from a file path.
  static JsModule path({required String module, required String path}) =>
      LibFjs.instance.api
          .crateApiSourceJsModulePath(module: module, path: path);
}
