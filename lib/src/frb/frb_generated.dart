// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/engine.dart';
import 'api/error.dart';
import 'api/runtime.dart';
import 'api/source.dart';
import 'api/value.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class LibFjs extends BaseEntrypoint<LibFjsApi, LibFjsApiImpl, LibFjsWire> {
  @internal
  static final instance = LibFjs._();

  LibFjs._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    LibFjsApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required LibFjsApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<LibFjsApiImpl, LibFjsWire> get apiImplConstructor =>
      LibFjsApiImpl.new;

  @override
  WireConstructor<LibFjsWire> get wireConstructor =>
      LibFjsWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => 2113920709;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'fjs',
    ioDirectory: 'libfjs/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class LibFjsApi extends BaseApi {
  Future<JsResult> crateApiRuntimeJsAsyncContextEval(
      {required JsAsyncContext that, required String code});

  Future<JsResult> crateApiRuntimeJsAsyncContextEvalFile(
      {required JsAsyncContext that, required String path});

  Future<JsResult> crateApiRuntimeJsAsyncContextEvalFileWithOptions(
      {required JsAsyncContext that,
      required String path,
      required JsEvalOptions options});

  Future<JsResult> crateApiRuntimeJsAsyncContextEvalFunction(
      {required JsAsyncContext that,
      required String module,
      required String method,
      List<JsValue>? params});

  Future<JsResult> crateApiRuntimeJsAsyncContextEvalWithOptions(
      {required JsAsyncContext that,
      required String code,
      required JsEvalOptions options});

  Future<JsAsyncContext> crateApiRuntimeJsAsyncContextFrom(
      {required JsAsyncRuntime runtime});

  Future<bool> crateApiRuntimeJsAsyncRuntimeExecutePendingJob(
      {required JsAsyncRuntime that});

  Future<void> crateApiRuntimeJsAsyncRuntimeIdle(
      {required JsAsyncRuntime that});

  Future<bool> crateApiRuntimeJsAsyncRuntimeIsJobPending(
      {required JsAsyncRuntime that});

  Future<MemoryUsage> crateApiRuntimeJsAsyncRuntimeMemoryUsage(
      {required JsAsyncRuntime that});

  JsAsyncRuntime crateApiRuntimeJsAsyncRuntimeNew();

  Future<void> crateApiRuntimeJsAsyncRuntimeRunGc(
      {required JsAsyncRuntime that});

  Future<void> crateApiRuntimeJsAsyncRuntimeSetGcThreshold(
      {required JsAsyncRuntime that, required BigInt threshold});

  Future<void> crateApiRuntimeJsAsyncRuntimeSetInfo(
      {required JsAsyncRuntime that, required String info});

  Future<void> crateApiRuntimeJsAsyncRuntimeSetMaxStackSize(
      {required JsAsyncRuntime that, required BigInt limit});

  Future<void> crateApiRuntimeJsAsyncRuntimeSetMemoryLimit(
      {required JsAsyncRuntime that, required BigInt limit});

  Future<JsAsyncRuntime> crateApiRuntimeJsAsyncRuntimeWithOptions(
      {JsBuiltinOptions? builtin, List<JsModule>? additional});

  JsResult crateApiRuntimeJsContextEval(
      {required JsContext that, required String code});

  JsResult crateApiRuntimeJsContextEvalFile(
      {required JsContext that, required String path});

  JsResult crateApiRuntimeJsContextEvalFileWithOptions(
      {required JsContext that,
      required String path,
      required JsEvalOptions options});

  JsResult crateApiRuntimeJsContextEvalWithOptions(
      {required JsContext that,
      required String code,
      required JsEvalOptions options});

  JsContext crateApiRuntimeJsContextFrom({required JsRuntime runtime});

  Future<JsValue> crateApiEngineJsEngineCall(
      {required JsEngine that,
      required String module,
      required String method,
      List<JsValue>? params});

  Future<void> crateApiEngineJsEngineClearNewModules({required JsEngine that});

  JsAsyncContext crateApiEngineJsEngineContext({required JsEngine that});

  Future<void> crateApiEngineJsEngineDeclareNewModule(
      {required JsEngine that, required JsModule module});

  Future<void> crateApiEngineJsEngineDeclareNewModules(
      {required JsEngine that, required List<JsModule> modules});

  Future<void> crateApiEngineJsEngineDispose({required JsEngine that});

  bool crateApiEngineJsEngineDisposed({required JsEngine that});

  Future<JsValue> crateApiEngineJsEngineEval(
      {required JsEngine that, required JsCode source, JsEvalOptions? options});

  Future<JsValue> crateApiEngineJsEngineEvaluateModule(
      {required JsEngine that, required JsModule module});

  Future<List<String>> crateApiEngineJsEngineGetDeclaredModules(
      {required JsEngine that});

  Future<void> crateApiEngineJsEngineInit(
      {required JsEngine that,
      required FutureOr<JsResult> Function(JsValue) bridge});

  Future<void> crateApiEngineJsEngineInitWithoutBridge(
      {required JsEngine that});

  Future<bool> crateApiEngineJsEngineIsModuleDeclared(
      {required JsEngine that, required String moduleName});

  JsEngine crateApiEngineJsEngineNew({required JsAsyncContext context});

  bool crateApiEngineJsEngineRunning({required JsEngine that});

  bool crateApiRuntimeJsRuntimeExecutePendingJob({required JsRuntime that});

  bool crateApiRuntimeJsRuntimeIsJobPending({required JsRuntime that});

  MemoryUsage crateApiRuntimeJsRuntimeMemoryUsage({required JsRuntime that});

  JsRuntime crateApiRuntimeJsRuntimeNew();

  void crateApiRuntimeJsRuntimeRunGc({required JsRuntime that});

  void crateApiRuntimeJsRuntimeSetDumpFlags(
      {required JsRuntime that, required BigInt flags});

  void crateApiRuntimeJsRuntimeSetGcThreshold(
      {required JsRuntime that, required BigInt threshold});

  void crateApiRuntimeJsRuntimeSetInfo(
      {required JsRuntime that, required String info});

  void crateApiRuntimeJsRuntimeSetMaxStackSize(
      {required JsRuntime that, required BigInt limit});

  void crateApiRuntimeJsRuntimeSetMemoryLimit(
      {required JsRuntime that, required BigInt limit});

  Future<JsRuntime> crateApiRuntimeJsRuntimeWithOptions(
      {JsBuiltinOptions? builtin, List<JsModule>? additional});

  PlatformInt64 crateApiRuntimeMemoryUsageArrayCount(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageAtomCount(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageAtomSize({required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageBinaryObjectCount(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageBinaryObjectSize(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageCFuncCount(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageFastArrayCount(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageFastArrayElements(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageJsFuncCodeSize(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageJsFuncCount(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageJsFuncPc2LineCount(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageJsFuncPc2LineSize(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageJsFuncSize(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageMallocCount(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageMallocLimit(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageMallocSize(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageMemoryUsedCount(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageMemoryUsedSize(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageObjCount({required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageObjSize({required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsagePropCount(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsagePropSize({required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageShapeCount(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageShapeSize(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageStrCount({required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageStrSize({required MemoryUsage that});

  String crateApiRuntimeMemoryUsageSummary({required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageTotalAllocations(
      {required MemoryUsage that});

  PlatformInt64 crateApiRuntimeMemoryUsageTotalMemory(
      {required MemoryUsage that});

  Future<void> crateApiInitApp();

  JsBuiltinOptions crateApiSourceJsBuiltinOptionsAll();

  Future<JsBuiltinOptions> crateApiSourceJsBuiltinOptionsDefault();

  JsBuiltinOptions crateApiSourceJsBuiltinOptionsEssential();

  JsBuiltinOptions crateApiSourceJsBuiltinOptionsNode();

  JsBuiltinOptions crateApiSourceJsBuiltinOptionsNone();

  JsBuiltinOptions crateApiSourceJsBuiltinOptionsWeb();

  bool crateApiSourceJsCodeIsBytes({required JsCode that});

  bool crateApiSourceJsCodeIsCode({required JsCode that});

  bool crateApiSourceJsCodeIsPath({required JsCode that});

  String crateApiErrorJsErrorCode({required JsError that});

  bool crateApiErrorJsErrorIsRecoverable({required JsError that});

  String crateApiErrorJsErrorToString({required JsError that});

  Future<JsEvalOptions> crateApiSourceJsEvalOptionsDefault();

  JsEvalOptions crateApiSourceJsEvalOptionsDefaults();

  JsEvalOptions crateApiSourceJsEvalOptionsModule();

  JsEvalOptions crateApiSourceJsEvalOptionsNew(
      {bool? global, bool? strict, bool? backtraceBarrier, bool? promise});

  JsEvalOptions crateApiSourceJsEvalOptionsWithPromise();

  JsModule crateApiSourceJsModuleBytes(
      {required String module, required List<int> bytes});

  JsModule crateApiSourceJsModuleCode(
      {required String module, required String code});

  JsModule crateApiSourceJsModuleNew(
      {required String name, required JsCode source});

  JsModule crateApiSourceJsModulePath(
      {required String module, required String path});

  Future<JsValue> crateApiValueJsValueDefault();

  bool crateApiValueJsValueIsArray({required JsValue that});

  bool crateApiValueJsValueIsBoolean({required JsValue that});

  bool crateApiValueJsValueIsBytes({required JsValue that});

  bool crateApiValueJsValueIsDate({required JsValue that});

  bool crateApiValueJsValueIsNone({required JsValue that});

  bool crateApiValueJsValueIsNumber({required JsValue that});

  bool crateApiValueJsValueIsObject({required JsValue that});

  bool crateApiValueJsValueIsPrimitive({required JsValue that});

  bool crateApiValueJsValueIsString({required JsValue that});

  String crateApiValueJsValueTypeName({required JsValue that});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_JsAsyncContext;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_JsAsyncContext;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_JsAsyncContextPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_JsAsyncRuntime;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_JsAsyncRuntime;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_JsAsyncRuntimePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_JsContext;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_JsContext;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_JsContextPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_JsEngine;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_JsEngine;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_JsEnginePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_JsRuntime;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_JsRuntime;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_JsRuntimePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MemoryUsage;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MemoryUsage;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MemoryUsagePtr;
}

class LibFjsApiImpl extends LibFjsApiImplPlatform implements LibFjsApi {
  LibFjsApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<JsResult> crateApiRuntimeJsAsyncContextEval(
      {required JsAsyncContext that, required String code}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
            that, serializer);
        sse_encode_String(code, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsAsyncContextEvalConstMeta,
      argValues: [that, code],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncContextEvalConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncContext_eval",
        argNames: ["that", "code"],
      );

  @override
  Future<JsResult> crateApiRuntimeJsAsyncContextEvalFile(
      {required JsAsyncContext that, required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
            that, serializer);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsAsyncContextEvalFileConstMeta,
      argValues: [that, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncContextEvalFileConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncContext_eval_file",
        argNames: ["that", "path"],
      );

  @override
  Future<JsResult> crateApiRuntimeJsAsyncContextEvalFileWithOptions(
      {required JsAsyncContext that,
      required String path,
      required JsEvalOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
            that, serializer);
        sse_encode_String(path, serializer);
        sse_encode_box_autoadd_js_eval_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsAsyncContextEvalFileWithOptionsConstMeta,
      argValues: [that, path, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiRuntimeJsAsyncContextEvalFileWithOptionsConstMeta =>
          const TaskConstMeta(
            debugName: "JsAsyncContext_eval_file_with_options",
            argNames: ["that", "path", "options"],
          );

  @override
  Future<JsResult> crateApiRuntimeJsAsyncContextEvalFunction(
      {required JsAsyncContext that,
      required String module,
      required String method,
      List<JsValue>? params}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
            that, serializer);
        sse_encode_String(module, serializer);
        sse_encode_String(method, serializer);
        sse_encode_opt_list_js_value(params, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsAsyncContextEvalFunctionConstMeta,
      argValues: [that, module, method, params],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncContextEvalFunctionConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncContext_eval_function",
        argNames: ["that", "module", "method", "params"],
      );

  @override
  Future<JsResult> crateApiRuntimeJsAsyncContextEvalWithOptions(
      {required JsAsyncContext that,
      required String code,
      required JsEvalOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
            that, serializer);
        sse_encode_String(code, serializer);
        sse_encode_box_autoadd_js_eval_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsAsyncContextEvalWithOptionsConstMeta,
      argValues: [that, code, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncContextEvalWithOptionsConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncContext_eval_with_options",
        argNames: ["that", "code", "options"],
      );

  @override
  Future<JsAsyncContext> crateApiRuntimeJsAsyncContextFrom(
      {required JsAsyncRuntime runtime}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
            runtime, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiRuntimeJsAsyncContextFromConstMeta,
      argValues: [runtime],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncContextFromConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncContext_from",
        argNames: ["runtime"],
      );

  @override
  Future<bool> crateApiRuntimeJsAsyncRuntimeExecutePendingJob(
      {required JsAsyncRuntime that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiRuntimeJsAsyncRuntimeExecutePendingJobConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncRuntimeExecutePendingJobConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncRuntime_execute_pending_job",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiRuntimeJsAsyncRuntimeIdle(
      {required JsAsyncRuntime that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsAsyncRuntimeIdleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncRuntimeIdleConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncRuntime_idle",
        argNames: ["that"],
      );

  @override
  Future<bool> crateApiRuntimeJsAsyncRuntimeIsJobPending(
      {required JsAsyncRuntime that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsAsyncRuntimeIsJobPendingConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncRuntimeIsJobPendingConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncRuntime_is_job_pending",
        argNames: ["that"],
      );

  @override
  Future<MemoryUsage> crateApiRuntimeJsAsyncRuntimeMemoryUsage(
      {required JsAsyncRuntime that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsAsyncRuntimeMemoryUsageConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncRuntimeMemoryUsageConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncRuntime_memory_usage",
        argNames: ["that"],
      );

  @override
  JsAsyncRuntime crateApiRuntimeJsAsyncRuntimeNew() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiRuntimeJsAsyncRuntimeNewConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncRuntimeNewConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncRuntime_new",
        argNames: [],
      );

  @override
  Future<void> crateApiRuntimeJsAsyncRuntimeRunGc(
      {required JsAsyncRuntime that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsAsyncRuntimeRunGcConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncRuntimeRunGcConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncRuntime_run_gc",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiRuntimeJsAsyncRuntimeSetGcThreshold(
      {required JsAsyncRuntime that, required BigInt threshold}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
            that, serializer);
        sse_encode_usize(threshold, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsAsyncRuntimeSetGcThresholdConstMeta,
      argValues: [that, threshold],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncRuntimeSetGcThresholdConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncRuntime_set_gc_threshold",
        argNames: ["that", "threshold"],
      );

  @override
  Future<void> crateApiRuntimeJsAsyncRuntimeSetInfo(
      {required JsAsyncRuntime that, required String info}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
            that, serializer);
        sse_encode_String(info, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiRuntimeJsAsyncRuntimeSetInfoConstMeta,
      argValues: [that, info],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncRuntimeSetInfoConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncRuntime_set_info",
        argNames: ["that", "info"],
      );

  @override
  Future<void> crateApiRuntimeJsAsyncRuntimeSetMaxStackSize(
      {required JsAsyncRuntime that, required BigInt limit}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
            that, serializer);
        sse_encode_usize(limit, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsAsyncRuntimeSetMaxStackSizeConstMeta,
      argValues: [that, limit],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncRuntimeSetMaxStackSizeConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncRuntime_set_max_stack_size",
        argNames: ["that", "limit"],
      );

  @override
  Future<void> crateApiRuntimeJsAsyncRuntimeSetMemoryLimit(
      {required JsAsyncRuntime that, required BigInt limit}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
            that, serializer);
        sse_encode_usize(limit, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsAsyncRuntimeSetMemoryLimitConstMeta,
      argValues: [that, limit],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncRuntimeSetMemoryLimitConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncRuntime_set_memory_limit",
        argNames: ["that", "limit"],
      );

  @override
  Future<JsAsyncRuntime> crateApiRuntimeJsAsyncRuntimeWithOptions(
      {JsBuiltinOptions? builtin, List<JsModule>? additional}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_opt_box_autoadd_js_builtin_options(builtin, serializer);
        sse_encode_opt_list_js_module(additional, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiRuntimeJsAsyncRuntimeWithOptionsConstMeta,
      argValues: [builtin, additional],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsAsyncRuntimeWithOptionsConstMeta =>
      const TaskConstMeta(
        debugName: "JsAsyncRuntime_with_options",
        argNames: ["builtin", "additional"],
      );

  @override
  JsResult crateApiRuntimeJsContextEval(
      {required JsContext that, required String code}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext(
            that, serializer);
        sse_encode_String(code, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsContextEvalConstMeta,
      argValues: [that, code],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsContextEvalConstMeta =>
      const TaskConstMeta(
        debugName: "JsContext_eval",
        argNames: ["that", "code"],
      );

  @override
  JsResult crateApiRuntimeJsContextEvalFile(
      {required JsContext that, required String path}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext(
            that, serializer);
        sse_encode_String(path, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsContextEvalFileConstMeta,
      argValues: [that, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsContextEvalFileConstMeta =>
      const TaskConstMeta(
        debugName: "JsContext_eval_file",
        argNames: ["that", "path"],
      );

  @override
  JsResult crateApiRuntimeJsContextEvalFileWithOptions(
      {required JsContext that,
      required String path,
      required JsEvalOptions options}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext(
            that, serializer);
        sse_encode_String(path, serializer);
        sse_encode_box_autoadd_js_eval_options(options, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsContextEvalFileWithOptionsConstMeta,
      argValues: [that, path, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsContextEvalFileWithOptionsConstMeta =>
      const TaskConstMeta(
        debugName: "JsContext_eval_file_with_options",
        argNames: ["that", "path", "options"],
      );

  @override
  JsResult crateApiRuntimeJsContextEvalWithOptions(
      {required JsContext that,
      required String code,
      required JsEvalOptions options}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext(
            that, serializer);
        sse_encode_String(code, serializer);
        sse_encode_box_autoadd_js_eval_options(options, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 21)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsContextEvalWithOptionsConstMeta,
      argValues: [that, code, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsContextEvalWithOptionsConstMeta =>
      const TaskConstMeta(
        debugName: "JsContext_eval_with_options",
        argNames: ["that", "code", "options"],
      );

  @override
  JsContext crateApiRuntimeJsContextFrom({required JsRuntime runtime}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
            runtime, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 22)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiRuntimeJsContextFromConstMeta,
      argValues: [runtime],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsContextFromConstMeta =>
      const TaskConstMeta(
        debugName: "JsContext_from",
        argNames: ["runtime"],
      );

  @override
  Future<JsValue> crateApiEngineJsEngineCall(
      {required JsEngine that,
      required String module,
      required String method,
      List<JsValue>? params}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        sse_encode_String(module, serializer);
        sse_encode_String(method, serializer);
        sse_encode_opt_list_js_value(params, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_value,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEngineJsEngineCallConstMeta,
      argValues: [that, module, method, params],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineCallConstMeta => const TaskConstMeta(
        debugName: "JsEngine_call",
        argNames: ["that", "module", "method", "params"],
      );

  @override
  Future<void> crateApiEngineJsEngineClearNewModules({required JsEngine that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEngineJsEngineClearNewModulesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineClearNewModulesConstMeta =>
      const TaskConstMeta(
        debugName: "JsEngine_clear_new_modules",
        argNames: ["that"],
      );

  @override
  JsAsyncContext crateApiEngineJsEngineContext({required JsEngine that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEngineJsEngineContextConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineContextConstMeta =>
      const TaskConstMeta(
        debugName: "JsEngine_context",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiEngineJsEngineDeclareNewModule(
      {required JsEngine that, required JsModule module}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        sse_encode_box_autoadd_js_module(module, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEngineJsEngineDeclareNewModuleConstMeta,
      argValues: [that, module],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineDeclareNewModuleConstMeta =>
      const TaskConstMeta(
        debugName: "JsEngine_declare_new_module",
        argNames: ["that", "module"],
      );

  @override
  Future<void> crateApiEngineJsEngineDeclareNewModules(
      {required JsEngine that, required List<JsModule> modules}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        sse_encode_list_js_module(modules, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEngineJsEngineDeclareNewModulesConstMeta,
      argValues: [that, modules],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineDeclareNewModulesConstMeta =>
      const TaskConstMeta(
        debugName: "JsEngine_declare_new_modules",
        argNames: ["that", "modules"],
      );

  @override
  Future<void> crateApiEngineJsEngineDispose({required JsEngine that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEngineJsEngineDisposeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineDisposeConstMeta =>
      const TaskConstMeta(
        debugName: "JsEngine_dispose",
        argNames: ["that"],
      );

  @override
  bool crateApiEngineJsEngineDisposed({required JsEngine that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEngineJsEngineDisposedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineDisposedConstMeta =>
      const TaskConstMeta(
        debugName: "JsEngine_disposed",
        argNames: ["that"],
      );

  @override
  Future<JsValue> crateApiEngineJsEngineEval(
      {required JsEngine that,
      required JsCode source,
      JsEvalOptions? options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        sse_encode_box_autoadd_js_code(source, serializer);
        sse_encode_opt_box_autoadd_js_eval_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_value,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEngineJsEngineEvalConstMeta,
      argValues: [that, source, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineEvalConstMeta => const TaskConstMeta(
        debugName: "JsEngine_eval",
        argNames: ["that", "source", "options"],
      );

  @override
  Future<JsValue> crateApiEngineJsEngineEvaluateModule(
      {required JsEngine that, required JsModule module}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        sse_encode_box_autoadd_js_module(module, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_value,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEngineJsEngineEvaluateModuleConstMeta,
      argValues: [that, module],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineEvaluateModuleConstMeta =>
      const TaskConstMeta(
        debugName: "JsEngine_evaluate_module",
        argNames: ["that", "module"],
      );

  @override
  Future<List<String>> crateApiEngineJsEngineGetDeclaredModules(
      {required JsEngine that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEngineJsEngineGetDeclaredModulesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineGetDeclaredModulesConstMeta =>
      const TaskConstMeta(
        debugName: "JsEngine_get_declared_modules",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiEngineJsEngineInit(
      {required JsEngine that,
      required FutureOr<JsResult> Function(JsValue) bridge}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        sse_encode_DartFn_Inputs_js_value_Output_js_result_AnyhowException(
            bridge, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEngineJsEngineInitConstMeta,
      argValues: [that, bridge],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineInitConstMeta => const TaskConstMeta(
        debugName: "JsEngine_init",
        argNames: ["that", "bridge"],
      );

  @override
  Future<void> crateApiEngineJsEngineInitWithoutBridge(
      {required JsEngine that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEngineJsEngineInitWithoutBridgeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineInitWithoutBridgeConstMeta =>
      const TaskConstMeta(
        debugName: "JsEngine_init_without_bridge",
        argNames: ["that"],
      );

  @override
  Future<bool> crateApiEngineJsEngineIsModuleDeclared(
      {required JsEngine that, required String moduleName}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        sse_encode_String(moduleName, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEngineJsEngineIsModuleDeclaredConstMeta,
      argValues: [that, moduleName],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineIsModuleDeclaredConstMeta =>
      const TaskConstMeta(
        debugName: "JsEngine_is_module_declared",
        argNames: ["that", "moduleName"],
      );

  @override
  JsEngine crateApiEngineJsEngineNew({required JsAsyncContext context}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
            context, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEngineJsEngineNewConstMeta,
      argValues: [context],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineNewConstMeta => const TaskConstMeta(
        debugName: "JsEngine_new",
        argNames: ["context"],
      );

  @override
  bool crateApiEngineJsEngineRunning({required JsEngine that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEngineJsEngineRunningConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEngineJsEngineRunningConstMeta =>
      const TaskConstMeta(
        debugName: "JsEngine_running",
        argNames: ["that"],
      );

  @override
  bool crateApiRuntimeJsRuntimeExecutePendingJob({required JsRuntime that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 38)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiRuntimeJsRuntimeExecutePendingJobConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsRuntimeExecutePendingJobConstMeta =>
      const TaskConstMeta(
        debugName: "JsRuntime_execute_pending_job",
        argNames: ["that"],
      );

  @override
  bool crateApiRuntimeJsRuntimeIsJobPending({required JsRuntime that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 39)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsRuntimeIsJobPendingConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsRuntimeIsJobPendingConstMeta =>
      const TaskConstMeta(
        debugName: "JsRuntime_is_job_pending",
        argNames: ["that"],
      );

  @override
  MemoryUsage crateApiRuntimeJsRuntimeMemoryUsage({required JsRuntime that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 40)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsRuntimeMemoryUsageConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsRuntimeMemoryUsageConstMeta =>
      const TaskConstMeta(
        debugName: "JsRuntime_memory_usage",
        argNames: ["that"],
      );

  @override
  JsRuntime crateApiRuntimeJsRuntimeNew() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 41)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiRuntimeJsRuntimeNewConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsRuntimeNewConstMeta =>
      const TaskConstMeta(
        debugName: "JsRuntime_new",
        argNames: [],
      );

  @override
  void crateApiRuntimeJsRuntimeRunGc({required JsRuntime that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsRuntimeRunGcConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsRuntimeRunGcConstMeta =>
      const TaskConstMeta(
        debugName: "JsRuntime_run_gc",
        argNames: ["that"],
      );

  @override
  void crateApiRuntimeJsRuntimeSetDumpFlags(
      {required JsRuntime that, required BigInt flags}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
            that, serializer);
        sse_encode_u_64(flags, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsRuntimeSetDumpFlagsConstMeta,
      argValues: [that, flags],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsRuntimeSetDumpFlagsConstMeta =>
      const TaskConstMeta(
        debugName: "JsRuntime_set_dump_flags",
        argNames: ["that", "flags"],
      );

  @override
  void crateApiRuntimeJsRuntimeSetGcThreshold(
      {required JsRuntime that, required BigInt threshold}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
            that, serializer);
        sse_encode_usize(threshold, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 44)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsRuntimeSetGcThresholdConstMeta,
      argValues: [that, threshold],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsRuntimeSetGcThresholdConstMeta =>
      const TaskConstMeta(
        debugName: "JsRuntime_set_gc_threshold",
        argNames: ["that", "threshold"],
      );

  @override
  void crateApiRuntimeJsRuntimeSetInfo(
      {required JsRuntime that, required String info}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
            that, serializer);
        sse_encode_String(info, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 45)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiRuntimeJsRuntimeSetInfoConstMeta,
      argValues: [that, info],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsRuntimeSetInfoConstMeta =>
      const TaskConstMeta(
        debugName: "JsRuntime_set_info",
        argNames: ["that", "info"],
      );

  @override
  void crateApiRuntimeJsRuntimeSetMaxStackSize(
      {required JsRuntime that, required BigInt limit}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
            that, serializer);
        sse_encode_usize(limit, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 46)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsRuntimeSetMaxStackSizeConstMeta,
      argValues: [that, limit],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsRuntimeSetMaxStackSizeConstMeta =>
      const TaskConstMeta(
        debugName: "JsRuntime_set_max_stack_size",
        argNames: ["that", "limit"],
      );

  @override
  void crateApiRuntimeJsRuntimeSetMemoryLimit(
      {required JsRuntime that, required BigInt limit}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
            that, serializer);
        sse_encode_usize(limit, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 47)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeJsRuntimeSetMemoryLimitConstMeta,
      argValues: [that, limit],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsRuntimeSetMemoryLimitConstMeta =>
      const TaskConstMeta(
        debugName: "JsRuntime_set_memory_limit",
        argNames: ["that", "limit"],
      );

  @override
  Future<JsRuntime> crateApiRuntimeJsRuntimeWithOptions(
      {JsBuiltinOptions? builtin, List<JsModule>? additional}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_opt_box_autoadd_js_builtin_options(builtin, serializer);
        sse_encode_opt_list_js_module(additional, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiRuntimeJsRuntimeWithOptionsConstMeta,
      argValues: [builtin, additional],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeJsRuntimeWithOptionsConstMeta =>
      const TaskConstMeta(
        debugName: "JsRuntime_with_options",
        argNames: ["builtin", "additional"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageArrayCount(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 49)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageArrayCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageArrayCountConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_array_count",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageAtomCount(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 50)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageAtomCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageAtomCountConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_atom_count",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageAtomSize(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 51)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageAtomSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageAtomSizeConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_atom_size",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageBinaryObjectCount(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 52)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageBinaryObjectCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageBinaryObjectCountConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_binary_object_count",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageBinaryObjectSize(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 53)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageBinaryObjectSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageBinaryObjectSizeConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_binary_object_size",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageCFuncCount(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 54)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageCFuncCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageCFuncCountConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_c_func_count",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageFastArrayCount(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 55)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageFastArrayCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageFastArrayCountConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_fast_array_count",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageFastArrayElements(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 56)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageFastArrayElementsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageFastArrayElementsConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_fast_array_elements",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageJsFuncCodeSize(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 57)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageJsFuncCodeSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageJsFuncCodeSizeConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_js_func_code_size",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageJsFuncCount(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 58)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageJsFuncCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageJsFuncCountConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_js_func_count",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageJsFuncPc2LineCount(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 59)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageJsFuncPc2LineCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageJsFuncPc2LineCountConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_js_func_pc2line_count",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageJsFuncPc2LineSize(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 60)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageJsFuncPc2LineSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageJsFuncPc2LineSizeConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_js_func_pc2line_size",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageJsFuncSize(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 61)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageJsFuncSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageJsFuncSizeConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_js_func_size",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageMallocCount(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 62)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageMallocCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageMallocCountConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_malloc_count",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageMallocLimit(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 63)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageMallocLimitConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageMallocLimitConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_malloc_limit",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageMallocSize(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 64)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageMallocSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageMallocSizeConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_malloc_size",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageMemoryUsedCount(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 65)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageMemoryUsedCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageMemoryUsedCountConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_memory_used_count",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageMemoryUsedSize(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 66)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageMemoryUsedSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageMemoryUsedSizeConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_memory_used_size",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageObjCount(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 67)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageObjCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageObjCountConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_obj_count",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageObjSize({required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 68)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageObjSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageObjSizeConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_obj_size",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsagePropCount(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 69)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsagePropCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsagePropCountConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_prop_count",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsagePropSize(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 70)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsagePropSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsagePropSizeConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_prop_size",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageShapeCount(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 71)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageShapeCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageShapeCountConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_shape_count",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageShapeSize(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 72)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageShapeSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageShapeSizeConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_shape_size",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageStrCount(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 73)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageStrCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageStrCountConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_str_count",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageStrSize({required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 74)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageStrSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageStrSizeConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_str_size",
        argNames: ["that"],
      );

  @override
  String crateApiRuntimeMemoryUsageSummary({required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 75)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageSummaryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageSummaryConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_summary",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageTotalAllocations(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 76)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageTotalAllocationsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageTotalAllocationsConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_total_allocations",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiRuntimeMemoryUsageTotalMemory(
      {required MemoryUsage that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 77)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRuntimeMemoryUsageTotalMemoryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRuntimeMemoryUsageTotalMemoryConstMeta =>
      const TaskConstMeta(
        debugName: "MemoryUsage_total_memory",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 78, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  JsBuiltinOptions crateApiSourceJsBuiltinOptionsAll() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 79)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_builtin_options,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsBuiltinOptionsAllConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsBuiltinOptionsAllConstMeta =>
      const TaskConstMeta(
        debugName: "js_builtin_options_all",
        argNames: [],
      );

  @override
  Future<JsBuiltinOptions> crateApiSourceJsBuiltinOptionsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 80, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_builtin_options,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsBuiltinOptionsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsBuiltinOptionsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "js_builtin_options_default",
        argNames: [],
      );

  @override
  JsBuiltinOptions crateApiSourceJsBuiltinOptionsEssential() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 81)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_builtin_options,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsBuiltinOptionsEssentialConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsBuiltinOptionsEssentialConstMeta =>
      const TaskConstMeta(
        debugName: "js_builtin_options_essential",
        argNames: [],
      );

  @override
  JsBuiltinOptions crateApiSourceJsBuiltinOptionsNode() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 82)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_builtin_options,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsBuiltinOptionsNodeConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsBuiltinOptionsNodeConstMeta =>
      const TaskConstMeta(
        debugName: "js_builtin_options_node",
        argNames: [],
      );

  @override
  JsBuiltinOptions crateApiSourceJsBuiltinOptionsNone() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 83)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_builtin_options,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsBuiltinOptionsNoneConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsBuiltinOptionsNoneConstMeta =>
      const TaskConstMeta(
        debugName: "js_builtin_options_none",
        argNames: [],
      );

  @override
  JsBuiltinOptions crateApiSourceJsBuiltinOptionsWeb() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 84)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_builtin_options,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsBuiltinOptionsWebConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsBuiltinOptionsWebConstMeta =>
      const TaskConstMeta(
        debugName: "js_builtin_options_web",
        argNames: [],
      );

  @override
  bool crateApiSourceJsCodeIsBytes({required JsCode that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_code(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 85)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsCodeIsBytesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsCodeIsBytesConstMeta =>
      const TaskConstMeta(
        debugName: "js_code_is_bytes",
        argNames: ["that"],
      );

  @override
  bool crateApiSourceJsCodeIsCode({required JsCode that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_code(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 86)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsCodeIsCodeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsCodeIsCodeConstMeta => const TaskConstMeta(
        debugName: "js_code_is_code",
        argNames: ["that"],
      );

  @override
  bool crateApiSourceJsCodeIsPath({required JsCode that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_code(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 87)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsCodeIsPathConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsCodeIsPathConstMeta => const TaskConstMeta(
        debugName: "js_code_is_path",
        argNames: ["that"],
      );

  @override
  String crateApiErrorJsErrorCode({required JsError that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_error(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 88)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiErrorJsErrorCodeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiErrorJsErrorCodeConstMeta => const TaskConstMeta(
        debugName: "js_error_code",
        argNames: ["that"],
      );

  @override
  bool crateApiErrorJsErrorIsRecoverable({required JsError that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_error(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 89)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiErrorJsErrorIsRecoverableConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiErrorJsErrorIsRecoverableConstMeta =>
      const TaskConstMeta(
        debugName: "js_error_is_recoverable",
        argNames: ["that"],
      );

  @override
  String crateApiErrorJsErrorToString({required JsError that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_error(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 90)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiErrorJsErrorToStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiErrorJsErrorToStringConstMeta =>
      const TaskConstMeta(
        debugName: "js_error_to_string",
        argNames: ["that"],
      );

  @override
  Future<JsEvalOptions> crateApiSourceJsEvalOptionsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 91, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_eval_options,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsEvalOptionsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsEvalOptionsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "js_eval_options_default",
        argNames: [],
      );

  @override
  JsEvalOptions crateApiSourceJsEvalOptionsDefaults() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 92)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_eval_options,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsEvalOptionsDefaultsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsEvalOptionsDefaultsConstMeta =>
      const TaskConstMeta(
        debugName: "js_eval_options_defaults",
        argNames: [],
      );

  @override
  JsEvalOptions crateApiSourceJsEvalOptionsModule() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 93)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_eval_options,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsEvalOptionsModuleConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsEvalOptionsModuleConstMeta =>
      const TaskConstMeta(
        debugName: "js_eval_options_module",
        argNames: [],
      );

  @override
  JsEvalOptions crateApiSourceJsEvalOptionsNew(
      {bool? global, bool? strict, bool? backtraceBarrier, bool? promise}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_opt_box_autoadd_bool(global, serializer);
        sse_encode_opt_box_autoadd_bool(strict, serializer);
        sse_encode_opt_box_autoadd_bool(backtraceBarrier, serializer);
        sse_encode_opt_box_autoadd_bool(promise, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 94)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_eval_options,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsEvalOptionsNewConstMeta,
      argValues: [global, strict, backtraceBarrier, promise],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsEvalOptionsNewConstMeta =>
      const TaskConstMeta(
        debugName: "js_eval_options_new",
        argNames: ["global", "strict", "backtraceBarrier", "promise"],
      );

  @override
  JsEvalOptions crateApiSourceJsEvalOptionsWithPromise() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 95)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_eval_options,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsEvalOptionsWithPromiseConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsEvalOptionsWithPromiseConstMeta =>
      const TaskConstMeta(
        debugName: "js_eval_options_with_promise",
        argNames: [],
      );

  @override
  JsModule crateApiSourceJsModuleBytes(
      {required String module, required List<int> bytes}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(module, serializer);
        sse_encode_list_prim_u_8_loose(bytes, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 96)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_module,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsModuleBytesConstMeta,
      argValues: [module, bytes],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsModuleBytesConstMeta =>
      const TaskConstMeta(
        debugName: "js_module_bytes",
        argNames: ["module", "bytes"],
      );

  @override
  JsModule crateApiSourceJsModuleCode(
      {required String module, required String code}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(module, serializer);
        sse_encode_String(code, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 97)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_module,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsModuleCodeConstMeta,
      argValues: [module, code],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsModuleCodeConstMeta => const TaskConstMeta(
        debugName: "js_module_code",
        argNames: ["module", "code"],
      );

  @override
  JsModule crateApiSourceJsModuleNew(
      {required String name, required JsCode source}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        sse_encode_box_autoadd_js_code(source, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 98)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_module,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsModuleNewConstMeta,
      argValues: [name, source],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsModuleNewConstMeta => const TaskConstMeta(
        debugName: "js_module_new",
        argNames: ["name", "source"],
      );

  @override
  JsModule crateApiSourceJsModulePath(
      {required String module, required String path}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(module, serializer);
        sse_encode_String(path, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 99)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_module,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSourceJsModulePathConstMeta,
      argValues: [module, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSourceJsModulePathConstMeta => const TaskConstMeta(
        debugName: "js_module_path",
        argNames: ["module", "path"],
      );

  @override
  Future<JsValue> crateApiValueJsValueDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 100, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_js_value,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiValueJsValueDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiValueJsValueDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "js_value_default",
        argNames: [],
      );

  @override
  bool crateApiValueJsValueIsArray({required JsValue that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_value(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 101)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiValueJsValueIsArrayConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiValueJsValueIsArrayConstMeta =>
      const TaskConstMeta(
        debugName: "js_value_is_array",
        argNames: ["that"],
      );

  @override
  bool crateApiValueJsValueIsBoolean({required JsValue that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_value(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 102)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiValueJsValueIsBooleanConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiValueJsValueIsBooleanConstMeta =>
      const TaskConstMeta(
        debugName: "js_value_is_boolean",
        argNames: ["that"],
      );

  @override
  bool crateApiValueJsValueIsBytes({required JsValue that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_value(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 103)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiValueJsValueIsBytesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiValueJsValueIsBytesConstMeta =>
      const TaskConstMeta(
        debugName: "js_value_is_bytes",
        argNames: ["that"],
      );

  @override
  bool crateApiValueJsValueIsDate({required JsValue that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_value(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 104)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiValueJsValueIsDateConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiValueJsValueIsDateConstMeta => const TaskConstMeta(
        debugName: "js_value_is_date",
        argNames: ["that"],
      );

  @override
  bool crateApiValueJsValueIsNone({required JsValue that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_value(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 105)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiValueJsValueIsNoneConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiValueJsValueIsNoneConstMeta => const TaskConstMeta(
        debugName: "js_value_is_none",
        argNames: ["that"],
      );

  @override
  bool crateApiValueJsValueIsNumber({required JsValue that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_value(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 106)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiValueJsValueIsNumberConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiValueJsValueIsNumberConstMeta =>
      const TaskConstMeta(
        debugName: "js_value_is_number",
        argNames: ["that"],
      );

  @override
  bool crateApiValueJsValueIsObject({required JsValue that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_value(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 107)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiValueJsValueIsObjectConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiValueJsValueIsObjectConstMeta =>
      const TaskConstMeta(
        debugName: "js_value_is_object",
        argNames: ["that"],
      );

  @override
  bool crateApiValueJsValueIsPrimitive({required JsValue that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_value(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 108)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiValueJsValueIsPrimitiveConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiValueJsValueIsPrimitiveConstMeta =>
      const TaskConstMeta(
        debugName: "js_value_is_primitive",
        argNames: ["that"],
      );

  @override
  bool crateApiValueJsValueIsString({required JsValue that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_value(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 109)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiValueJsValueIsStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiValueJsValueIsStringConstMeta =>
      const TaskConstMeta(
        debugName: "js_value_is_string",
        argNames: ["that"],
      );

  @override
  String crateApiValueJsValueTypeName({required JsValue that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_js_value(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 110)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiValueJsValueTypeNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiValueJsValueTypeNameConstMeta =>
      const TaskConstMeta(
        debugName: "js_value_type_name",
        argNames: ["that"],
      );

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_js_value_Output_js_result_AnyhowException(
          FutureOr<JsResult> Function(JsValue) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_js_value(rawArg0);

      Box<JsResult>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_js_result(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_JsAsyncContext => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_JsAsyncContext => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_JsAsyncRuntime => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_JsAsyncRuntime => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_JsContext => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_JsContext => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_JsEngine => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_JsEngine => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_JsRuntime => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_JsRuntime => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MemoryUsage => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MemoryUsage => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  JsAsyncContext
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsAsyncContextImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  JsAsyncRuntime
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsAsyncRuntimeImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  JsContext
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsContextImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  JsEngine
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsEngineImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  JsRuntime
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsRuntimeImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MemoryUsage
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MemoryUsageImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  JsAsyncContext
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsAsyncContextImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  JsAsyncRuntime
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsAsyncRuntimeImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  JsContext
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsContextImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  JsEngine
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsEngineImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  JsRuntime
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsRuntimeImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MemoryUsage
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MemoryUsageImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FutureOr<JsResult> Function(JsValue)
      dco_decode_DartFn_Inputs_js_value_Output_js_result_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  Object dco_decode_DartOpaque(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return decodeDartOpaque(raw, generalizedFrbRustBinding);
  }

  @protected
  Map<String, JsValue> dco_decode_Map_String_js_value_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_js_value(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  JsAsyncContext
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsAsyncContextImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  JsAsyncRuntime
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsAsyncRuntimeImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  JsContext
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsContextImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  JsEngine
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsEngineImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  JsRuntime
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return JsRuntimeImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MemoryUsage
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MemoryUsageImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  JsBuiltinOptions dco_decode_box_autoadd_js_builtin_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_js_builtin_options(raw);
  }

  @protected
  JsCode dco_decode_box_autoadd_js_code(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_js_code(raw);
  }

  @protected
  JsError dco_decode_box_autoadd_js_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_js_error(raw);
  }

  @protected
  JsEvalOptions dco_decode_box_autoadd_js_eval_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_js_eval_options(raw);
  }

  @protected
  JsModule dco_decode_box_autoadd_js_module(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_js_module(raw);
  }

  @protected
  JsValue dco_decode_box_autoadd_js_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_js_value(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  PlatformInt64 dco_decode_isize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  JsBuiltinOptions dco_decode_js_builtin_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 26)
      throw Exception('unexpected arr length: expect 26 but see ${arr.length}');
    return JsBuiltinOptions(
      abort: dco_decode_opt_box_autoadd_bool(arr[0]),
      assert_: dco_decode_opt_box_autoadd_bool(arr[1]),
      asyncHooks: dco_decode_opt_box_autoadd_bool(arr[2]),
      buffer: dco_decode_opt_box_autoadd_bool(arr[3]),
      childProcess: dco_decode_opt_box_autoadd_bool(arr[4]),
      console: dco_decode_opt_box_autoadd_bool(arr[5]),
      crypto: dco_decode_opt_box_autoadd_bool(arr[6]),
      dns: dco_decode_opt_box_autoadd_bool(arr[7]),
      events: dco_decode_opt_box_autoadd_bool(arr[8]),
      exceptions: dco_decode_opt_box_autoadd_bool(arr[9]),
      fetch: dco_decode_opt_box_autoadd_bool(arr[10]),
      fs: dco_decode_opt_box_autoadd_bool(arr[11]),
      navigator: dco_decode_opt_box_autoadd_bool(arr[12]),
      net: dco_decode_opt_box_autoadd_bool(arr[13]),
      os: dco_decode_opt_box_autoadd_bool(arr[14]),
      path: dco_decode_opt_box_autoadd_bool(arr[15]),
      perfHooks: dco_decode_opt_box_autoadd_bool(arr[16]),
      process: dco_decode_opt_box_autoadd_bool(arr[17]),
      streamWeb: dco_decode_opt_box_autoadd_bool(arr[18]),
      stringDecoder: dco_decode_opt_box_autoadd_bool(arr[19]),
      timers: dco_decode_opt_box_autoadd_bool(arr[20]),
      tty: dco_decode_opt_box_autoadd_bool(arr[21]),
      url: dco_decode_opt_box_autoadd_bool(arr[22]),
      util: dco_decode_opt_box_autoadd_bool(arr[23]),
      zlib: dco_decode_opt_box_autoadd_bool(arr[24]),
      json: dco_decode_opt_box_autoadd_bool(arr[25]),
    );
  }

  @protected
  JsCode dco_decode_js_code(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return JsCode_Code(
          dco_decode_String(raw[1]),
        );
      case 1:
        return JsCode_Path(
          dco_decode_String(raw[1]),
        );
      case 2:
        return JsCode_Bytes(
          dco_decode_list_prim_u_8_strict(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  JsError dco_decode_js_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return JsError_Promise(
          dco_decode_String(raw[1]),
        );
      case 1:
        return JsError_Module(
          module: dco_decode_opt_String(raw[1]),
          method: dco_decode_opt_String(raw[2]),
          message: dco_decode_String(raw[3]),
        );
      case 2:
        return JsError_Context(
          dco_decode_String(raw[1]),
        );
      case 3:
        return JsError_Storage(
          dco_decode_String(raw[1]),
        );
      case 4:
        return JsError_Io(
          path: dco_decode_opt_String(raw[1]),
          message: dco_decode_String(raw[2]),
        );
      case 5:
        return JsError_Runtime(
          dco_decode_String(raw[1]),
        );
      case 6:
        return JsError_Generic(
          dco_decode_String(raw[1]),
        );
      case 7:
        return JsError_Engine(
          dco_decode_String(raw[1]),
        );
      case 8:
        return JsError_Bridge(
          dco_decode_String(raw[1]),
        );
      case 9:
        return JsError_Conversion(
          from: dco_decode_String(raw[1]),
          to: dco_decode_String(raw[2]),
          message: dco_decode_String(raw[3]),
        );
      case 10:
        return JsError_Timeout(
          operation: dco_decode_String(raw[1]),
          timeoutMs: dco_decode_u_64(raw[2]),
        );
      case 11:
        return JsError_MemoryLimit(
          current: dco_decode_u_64(raw[1]),
          limit: dco_decode_u_64(raw[2]),
        );
      case 12:
        return JsError_StackOverflow(
          dco_decode_String(raw[1]),
        );
      case 13:
        return JsError_Syntax(
          line: dco_decode_opt_box_autoadd_u_32(raw[1]),
          column: dco_decode_opt_box_autoadd_u_32(raw[2]),
          message: dco_decode_String(raw[3]),
        );
      case 14:
        return JsError_Reference(
          dco_decode_String(raw[1]),
        );
      case 15:
        return JsError_Type(
          dco_decode_String(raw[1]),
        );
      case 16:
        return JsError_Cancelled(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  JsEvalOptions dco_decode_js_eval_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return JsEvalOptions.raw(
      global: dco_decode_opt_box_autoadd_bool(arr[0]),
      strict: dco_decode_opt_box_autoadd_bool(arr[1]),
      backtraceBarrier: dco_decode_opt_box_autoadd_bool(arr[2]),
      promise: dco_decode_opt_box_autoadd_bool(arr[3]),
    );
  }

  @protected
  JsModule dco_decode_js_module(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return JsModule.raw(
      name: dco_decode_String(arr[0]),
      source: dco_decode_js_code(arr[1]),
    );
  }

  @protected
  JsResult dco_decode_js_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return JsResult_Ok(
          dco_decode_box_autoadd_js_value(raw[1]),
        );
      case 1:
        return JsResult_Err(
          dco_decode_box_autoadd_js_error(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  JsValue dco_decode_js_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return JsValue_None();
      case 1:
        return JsValue_Boolean(
          dco_decode_bool(raw[1]),
        );
      case 2:
        return JsValue_Integer(
          dco_decode_i_64(raw[1]),
        );
      case 3:
        return JsValue_Float(
          dco_decode_f_64(raw[1]),
        );
      case 4:
        return JsValue_Bigint(
          dco_decode_String(raw[1]),
        );
      case 5:
        return JsValue_String(
          dco_decode_String(raw[1]),
        );
      case 6:
        return JsValue_Bytes(
          dco_decode_list_prim_u_8_strict(raw[1]),
        );
      case 7:
        return JsValue_Array(
          dco_decode_list_js_value(raw[1]),
        );
      case 8:
        return JsValue_Object(
          dco_decode_Map_String_js_value_None(raw[1]),
        );
      case 9:
        return JsValue_Date(
          dco_decode_i_64(raw[1]),
        );
      case 10:
        return JsValue_Symbol(
          dco_decode_String(raw[1]),
        );
      case 11:
        return JsValue_Function(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<JsModule> dco_decode_list_js_module(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_js_module).toList();
  }

  @protected
  List<JsValue> dco_decode_list_js_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_js_value).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(String, JsValue)> dco_decode_list_record_string_js_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_js_value)
        .toList();
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  JsBuiltinOptions? dco_decode_opt_box_autoadd_js_builtin_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_js_builtin_options(raw);
  }

  @protected
  JsEvalOptions? dco_decode_opt_box_autoadd_js_eval_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_js_eval_options(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  List<JsModule>? dco_decode_opt_list_js_module(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_js_module(raw);
  }

  @protected
  List<JsValue>? dco_decode_opt_list_js_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_js_value(raw);
  }

  @protected
  (String, JsValue) dco_decode_record_string_js_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_js_value(arr[1]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  JsAsyncContext
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsAsyncContextImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  JsAsyncRuntime
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsAsyncRuntimeImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  JsContext
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsContextImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  JsEngine
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsEngineImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  JsRuntime
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsRuntimeImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MemoryUsage
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MemoryUsageImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  JsAsyncContext
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsAsyncContextImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  JsAsyncRuntime
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsAsyncRuntimeImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  JsContext
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsContextImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  JsEngine
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsEngineImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  JsRuntime
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsRuntimeImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MemoryUsage
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MemoryUsageImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Object sse_decode_DartOpaque(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_isize(deserializer);
    return decodeDartOpaque(inner, generalizedFrbRustBinding);
  }

  @protected
  Map<String, JsValue> sse_decode_Map_String_js_value_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_js_value(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  JsAsyncContext
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsAsyncContextImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  JsAsyncRuntime
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsAsyncRuntimeImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  JsContext
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsContextImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  JsEngine
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsEngineImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  JsRuntime
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return JsRuntimeImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MemoryUsage
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MemoryUsageImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  JsBuiltinOptions sse_decode_box_autoadd_js_builtin_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_js_builtin_options(deserializer));
  }

  @protected
  JsCode sse_decode_box_autoadd_js_code(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_js_code(deserializer));
  }

  @protected
  JsError sse_decode_box_autoadd_js_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_js_error(deserializer));
  }

  @protected
  JsEvalOptions sse_decode_box_autoadd_js_eval_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_js_eval_options(deserializer));
  }

  @protected
  JsModule sse_decode_box_autoadd_js_module(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_js_module(deserializer));
  }

  @protected
  JsValue sse_decode_box_autoadd_js_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_js_value(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  PlatformInt64 sse_decode_isize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  JsBuiltinOptions sse_decode_js_builtin_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_abort = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_assert_ = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_asyncHooks = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_buffer = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_childProcess = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_console = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_crypto = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_dns = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_events = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_exceptions = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_fetch = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_fs = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_navigator = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_net = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_os = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_path = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_perfHooks = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_process = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_streamWeb = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_stringDecoder = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_timers = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_tty = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_url = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_util = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_zlib = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_json = sse_decode_opt_box_autoadd_bool(deserializer);
    return JsBuiltinOptions(
        abort: var_abort,
        assert_: var_assert_,
        asyncHooks: var_asyncHooks,
        buffer: var_buffer,
        childProcess: var_childProcess,
        console: var_console,
        crypto: var_crypto,
        dns: var_dns,
        events: var_events,
        exceptions: var_exceptions,
        fetch: var_fetch,
        fs: var_fs,
        navigator: var_navigator,
        net: var_net,
        os: var_os,
        path: var_path,
        perfHooks: var_perfHooks,
        process: var_process,
        streamWeb: var_streamWeb,
        stringDecoder: var_stringDecoder,
        timers: var_timers,
        tty: var_tty,
        url: var_url,
        util: var_util,
        zlib: var_zlib,
        json: var_json);
  }

  @protected
  JsCode sse_decode_js_code(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return JsCode_Code(var_field0);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return JsCode_Path(var_field0);
      case 2:
        var var_field0 = sse_decode_list_prim_u_8_strict(deserializer);
        return JsCode_Bytes(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  JsError sse_decode_js_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return JsError_Promise(var_field0);
      case 1:
        var var_module = sse_decode_opt_String(deserializer);
        var var_method = sse_decode_opt_String(deserializer);
        var var_message = sse_decode_String(deserializer);
        return JsError_Module(
            module: var_module, method: var_method, message: var_message);
      case 2:
        var var_field0 = sse_decode_String(deserializer);
        return JsError_Context(var_field0);
      case 3:
        var var_field0 = sse_decode_String(deserializer);
        return JsError_Storage(var_field0);
      case 4:
        var var_path = sse_decode_opt_String(deserializer);
        var var_message = sse_decode_String(deserializer);
        return JsError_Io(path: var_path, message: var_message);
      case 5:
        var var_field0 = sse_decode_String(deserializer);
        return JsError_Runtime(var_field0);
      case 6:
        var var_field0 = sse_decode_String(deserializer);
        return JsError_Generic(var_field0);
      case 7:
        var var_field0 = sse_decode_String(deserializer);
        return JsError_Engine(var_field0);
      case 8:
        var var_field0 = sse_decode_String(deserializer);
        return JsError_Bridge(var_field0);
      case 9:
        var var_from = sse_decode_String(deserializer);
        var var_to = sse_decode_String(deserializer);
        var var_message = sse_decode_String(deserializer);
        return JsError_Conversion(
            from: var_from, to: var_to, message: var_message);
      case 10:
        var var_operation = sse_decode_String(deserializer);
        var var_timeoutMs = sse_decode_u_64(deserializer);
        return JsError_Timeout(
            operation: var_operation, timeoutMs: var_timeoutMs);
      case 11:
        var var_current = sse_decode_u_64(deserializer);
        var var_limit = sse_decode_u_64(deserializer);
        return JsError_MemoryLimit(current: var_current, limit: var_limit);
      case 12:
        var var_field0 = sse_decode_String(deserializer);
        return JsError_StackOverflow(var_field0);
      case 13:
        var var_line = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_column = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_message = sse_decode_String(deserializer);
        return JsError_Syntax(
            line: var_line, column: var_column, message: var_message);
      case 14:
        var var_field0 = sse_decode_String(deserializer);
        return JsError_Reference(var_field0);
      case 15:
        var var_field0 = sse_decode_String(deserializer);
        return JsError_Type(var_field0);
      case 16:
        var var_field0 = sse_decode_String(deserializer);
        return JsError_Cancelled(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  JsEvalOptions sse_decode_js_eval_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_global = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_strict = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_backtraceBarrier = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_promise = sse_decode_opt_box_autoadd_bool(deserializer);
    return JsEvalOptions.raw(
        global: var_global,
        strict: var_strict,
        backtraceBarrier: var_backtraceBarrier,
        promise: var_promise);
  }

  @protected
  JsModule sse_decode_js_module(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_source = sse_decode_js_code(deserializer);
    return JsModule.raw(name: var_name, source: var_source);
  }

  @protected
  JsResult sse_decode_js_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_box_autoadd_js_value(deserializer);
        return JsResult_Ok(var_field0);
      case 1:
        var var_field0 = sse_decode_box_autoadd_js_error(deserializer);
        return JsResult_Err(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  JsValue sse_decode_js_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return JsValue_None();
      case 1:
        var var_field0 = sse_decode_bool(deserializer);
        return JsValue_Boolean(var_field0);
      case 2:
        var var_field0 = sse_decode_i_64(deserializer);
        return JsValue_Integer(var_field0);
      case 3:
        var var_field0 = sse_decode_f_64(deserializer);
        return JsValue_Float(var_field0);
      case 4:
        var var_field0 = sse_decode_String(deserializer);
        return JsValue_Bigint(var_field0);
      case 5:
        var var_field0 = sse_decode_String(deserializer);
        return JsValue_String(var_field0);
      case 6:
        var var_field0 = sse_decode_list_prim_u_8_strict(deserializer);
        return JsValue_Bytes(var_field0);
      case 7:
        var var_field0 = sse_decode_list_js_value(deserializer);
        return JsValue_Array(var_field0);
      case 8:
        var var_field0 = sse_decode_Map_String_js_value_None(deserializer);
        return JsValue_Object(var_field0);
      case 9:
        var var_field0 = sse_decode_i_64(deserializer);
        return JsValue_Date(var_field0);
      case 10:
        var var_field0 = sse_decode_String(deserializer);
        return JsValue_Symbol(var_field0);
      case 11:
        var var_field0 = sse_decode_String(deserializer);
        return JsValue_Function(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<JsModule> sse_decode_list_js_module(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <JsModule>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_js_module(deserializer));
    }
    return ans_;
  }

  @protected
  List<JsValue> sse_decode_list_js_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <JsValue>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_js_value(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String, JsValue)> sse_decode_list_record_string_js_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, JsValue)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_js_value(deserializer));
    }
    return ans_;
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  JsBuiltinOptions? sse_decode_opt_box_autoadd_js_builtin_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_js_builtin_options(deserializer));
    } else {
      return null;
    }
  }

  @protected
  JsEvalOptions? sse_decode_opt_box_autoadd_js_eval_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_js_eval_options(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<JsModule>? sse_decode_opt_list_js_module(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_js_module(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<JsValue>? sse_decode_opt_list_js_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_js_value(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (String, JsValue) sse_decode_record_string_js_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_js_value(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
          JsAsyncContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsAsyncContextImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
          JsAsyncRuntime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsAsyncRuntimeImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext(
          JsContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsContextImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
          JsEngine self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsEngineImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
          JsRuntime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsRuntimeImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
          MemoryUsage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MemoryUsageImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
          JsAsyncContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsAsyncContextImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
          JsAsyncRuntime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsAsyncRuntimeImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext(
          JsContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsContextImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
          JsEngine self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsEngineImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
          JsRuntime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsRuntimeImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
          MemoryUsage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MemoryUsageImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_js_value_Output_js_result_AnyhowException(
      FutureOr<JsResult> Function(JsValue) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_js_value_Output_js_result_AnyhowException(self),
        serializer);
  }

  @protected
  void sse_encode_DartOpaque(Object self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_isize(
        PlatformPointerUtil.ptrToPlatformInt64(encodeDartOpaque(
            self, portManager.dartHandlerPort, generalizedFrbRustBinding)),
        serializer);
  }

  @protected
  void sse_encode_Map_String_js_value_None(
      Map<String, JsValue> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_js_value(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncContext(
          JsAsyncContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsAsyncContextImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsAsyncRuntime(
          JsAsyncRuntime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsAsyncRuntimeImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsContext(
          JsContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsContextImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsEngine(
          JsEngine self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsEngineImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerJsRuntime(
          JsRuntime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as JsRuntimeImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryUsage(
          MemoryUsage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MemoryUsageImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_js_builtin_options(
      JsBuiltinOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_js_builtin_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_js_code(JsCode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_js_code(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_js_error(JsError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_js_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_js_eval_options(
      JsEvalOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_js_eval_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_js_module(
      JsModule self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_js_module(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_js_value(JsValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_js_value(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_isize(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_js_builtin_options(
      JsBuiltinOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_bool(self.abort, serializer);
    sse_encode_opt_box_autoadd_bool(self.assert_, serializer);
    sse_encode_opt_box_autoadd_bool(self.asyncHooks, serializer);
    sse_encode_opt_box_autoadd_bool(self.buffer, serializer);
    sse_encode_opt_box_autoadd_bool(self.childProcess, serializer);
    sse_encode_opt_box_autoadd_bool(self.console, serializer);
    sse_encode_opt_box_autoadd_bool(self.crypto, serializer);
    sse_encode_opt_box_autoadd_bool(self.dns, serializer);
    sse_encode_opt_box_autoadd_bool(self.events, serializer);
    sse_encode_opt_box_autoadd_bool(self.exceptions, serializer);
    sse_encode_opt_box_autoadd_bool(self.fetch, serializer);
    sse_encode_opt_box_autoadd_bool(self.fs, serializer);
    sse_encode_opt_box_autoadd_bool(self.navigator, serializer);
    sse_encode_opt_box_autoadd_bool(self.net, serializer);
    sse_encode_opt_box_autoadd_bool(self.os, serializer);
    sse_encode_opt_box_autoadd_bool(self.path, serializer);
    sse_encode_opt_box_autoadd_bool(self.perfHooks, serializer);
    sse_encode_opt_box_autoadd_bool(self.process, serializer);
    sse_encode_opt_box_autoadd_bool(self.streamWeb, serializer);
    sse_encode_opt_box_autoadd_bool(self.stringDecoder, serializer);
    sse_encode_opt_box_autoadd_bool(self.timers, serializer);
    sse_encode_opt_box_autoadd_bool(self.tty, serializer);
    sse_encode_opt_box_autoadd_bool(self.url, serializer);
    sse_encode_opt_box_autoadd_bool(self.util, serializer);
    sse_encode_opt_box_autoadd_bool(self.zlib, serializer);
    sse_encode_opt_box_autoadd_bool(self.json, serializer);
  }

  @protected
  void sse_encode_js_code(JsCode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case JsCode_Code(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case JsCode_Path(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
      case JsCode_Bytes(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_list_prim_u_8_strict(field0, serializer);
    }
  }

  @protected
  void sse_encode_js_error(JsError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case JsError_Promise(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case JsError_Module(
          module: final module,
          method: final method,
          message: final message
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_String(module, serializer);
        sse_encode_opt_String(method, serializer);
        sse_encode_String(message, serializer);
      case JsError_Context(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_String(field0, serializer);
      case JsError_Storage(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_String(field0, serializer);
      case JsError_Io(path: final path, message: final message):
        sse_encode_i_32(4, serializer);
        sse_encode_opt_String(path, serializer);
        sse_encode_String(message, serializer);
      case JsError_Runtime(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_String(field0, serializer);
      case JsError_Generic(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_String(field0, serializer);
      case JsError_Engine(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_String(field0, serializer);
      case JsError_Bridge(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_String(field0, serializer);
      case JsError_Conversion(
          from: final from,
          to: final to,
          message: final message
        ):
        sse_encode_i_32(9, serializer);
        sse_encode_String(from, serializer);
        sse_encode_String(to, serializer);
        sse_encode_String(message, serializer);
      case JsError_Timeout(
          operation: final operation,
          timeoutMs: final timeoutMs
        ):
        sse_encode_i_32(10, serializer);
        sse_encode_String(operation, serializer);
        sse_encode_u_64(timeoutMs, serializer);
      case JsError_MemoryLimit(current: final current, limit: final limit):
        sse_encode_i_32(11, serializer);
        sse_encode_u_64(current, serializer);
        sse_encode_u_64(limit, serializer);
      case JsError_StackOverflow(field0: final field0):
        sse_encode_i_32(12, serializer);
        sse_encode_String(field0, serializer);
      case JsError_Syntax(
          line: final line,
          column: final column,
          message: final message
        ):
        sse_encode_i_32(13, serializer);
        sse_encode_opt_box_autoadd_u_32(line, serializer);
        sse_encode_opt_box_autoadd_u_32(column, serializer);
        sse_encode_String(message, serializer);
      case JsError_Reference(field0: final field0):
        sse_encode_i_32(14, serializer);
        sse_encode_String(field0, serializer);
      case JsError_Type(field0: final field0):
        sse_encode_i_32(15, serializer);
        sse_encode_String(field0, serializer);
      case JsError_Cancelled(field0: final field0):
        sse_encode_i_32(16, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_js_eval_options(
      JsEvalOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_bool(self.global, serializer);
    sse_encode_opt_box_autoadd_bool(self.strict, serializer);
    sse_encode_opt_box_autoadd_bool(self.backtraceBarrier, serializer);
    sse_encode_opt_box_autoadd_bool(self.promise, serializer);
  }

  @protected
  void sse_encode_js_module(JsModule self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_js_code(self.source, serializer);
  }

  @protected
  void sse_encode_js_result(JsResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case JsResult_Ok(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_js_value(field0, serializer);
      case JsResult_Err(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_js_error(field0, serializer);
    }
  }

  @protected
  void sse_encode_js_value(JsValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case JsValue_None():
        sse_encode_i_32(0, serializer);
      case JsValue_Boolean(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_bool(field0, serializer);
      case JsValue_Integer(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_i_64(field0, serializer);
      case JsValue_Float(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_f_64(field0, serializer);
      case JsValue_Bigint(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_String(field0, serializer);
      case JsValue_String(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_String(field0, serializer);
      case JsValue_Bytes(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_list_prim_u_8_strict(field0, serializer);
      case JsValue_Array(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_list_js_value(field0, serializer);
      case JsValue_Object(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_Map_String_js_value_None(field0, serializer);
      case JsValue_Date(field0: final field0):
        sse_encode_i_32(9, serializer);
        sse_encode_i_64(field0, serializer);
      case JsValue_Symbol(field0: final field0):
        sse_encode_i_32(10, serializer);
        sse_encode_String(field0, serializer);
      case JsValue_Function(field0: final field0):
        sse_encode_i_32(11, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_js_module(
      List<JsModule> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_js_module(item, serializer);
    }
  }

  @protected
  void sse_encode_list_js_value(List<JsValue> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_js_value(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_string_js_value(
      List<(String, JsValue)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_js_value(item, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_js_builtin_options(
      JsBuiltinOptions? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_js_builtin_options(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_js_eval_options(
      JsEvalOptions? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_js_eval_options(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_js_module(
      List<JsModule>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_js_module(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_js_value(
      List<JsValue>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_js_value(self, serializer);
    }
  }

  @protected
  void sse_encode_record_string_js_value(
      (String, JsValue) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_js_value(self.$2, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }
}

@sealed
class JsAsyncContextImpl extends RustOpaque implements JsAsyncContext {
  // Not to be used by end users
  JsAsyncContextImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  JsAsyncContextImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        LibFjs.instance.api.rust_arc_increment_strong_count_JsAsyncContext,
    rustArcDecrementStrongCount:
        LibFjs.instance.api.rust_arc_decrement_strong_count_JsAsyncContext,
    rustArcDecrementStrongCountPtr:
        LibFjs.instance.api.rust_arc_decrement_strong_count_JsAsyncContextPtr,
  );

  /// Evaluates JavaScript code.
  ///
  /// Evaluates the given code string with promise support enabled.
  /// Top-level await is supported.
  ///
  /// ## Parameters
  ///
  /// - `code`: JavaScript code to evaluate
  ///
  /// ## Returns
  ///
  /// The result of evaluation as a `JsValue`
  ///
  /// ## Example
  ///
  /// ```dart
  /// final result = await context.eval(code: 'await Promise.resolve(42)');
  /// print(result.value); // 42
  /// ```
  Future<JsResult> eval({required String code}) => LibFjs.instance.api
      .crateApiRuntimeJsAsyncContextEval(that: this, code: code);

  /// Evaluates JavaScript code from a file.
  ///
  /// Reads and executes JavaScript code from the specified file path.
  /// Promise support is automatically enabled.
  ///
  /// ## Parameters
  ///
  /// - `path`: Path to the JavaScript file
  ///
  /// ## Returns
  ///
  /// The result of evaluation as a `JsValue`
  ///
  /// ## Throws
  ///
  /// - If file cannot be read
  /// - If code evaluation fails
  ///
  /// ## Example
  ///
  /// ```dart
  /// final result = await context.evalFile(path: '/path/to/script.js');
  /// ```
  Future<JsResult> evalFile({required String path}) => LibFjs.instance.api
      .crateApiRuntimeJsAsyncContextEvalFile(that: this, path: path);

  /// Evaluates JavaScript code from a file with options.
  ///
  /// Reads and executes JavaScript code from the specified file path
  /// with custom evaluation options.
  ///
  /// ## Parameters
  ///
  /// - `path`: Path to the JavaScript file
  /// - `options`: Evaluation options
  ///
  /// ## Returns
  ///
  /// The result of evaluation as a `JsValue`
  ///
  /// ## Throws
  ///
  /// - If file cannot be read
  /// - If code evaluation fails
  Future<JsResult> evalFileWithOptions(
          {required String path, required JsEvalOptions options}) =>
      LibFjs.instance.api.crateApiRuntimeJsAsyncContextEvalFileWithOptions(
          that: this, path: path, options: options);

  /// Evaluates a function from a module.
  ///
  /// Imports the specified module and invokes one of its exported functions.
  ///
  /// ## Parameters
  /// - `module`: The module name to import
  /// - `method`: The function name to call (must be exported from the module)
  /// - `params`: Optional parameters to pass to the function
  ///
  /// ## Returns
  ///
  /// The result of the function call as a `JsValue`
  ///
  /// ## Throws
  ///
  /// - If the module cannot be imported
  /// - If the function does not exist
  /// - If the function call fails
  ///
  /// ## Example
  ///
  /// ```dart
  /// // Call a function with parameters
  /// final result = await context.evalFunction(
  ///   module: 'math-utils',
  ///   method: 'add',
  ///   params: [JsValue.integer(1), JsValue.integer(2)],
  /// );
  /// print(result.value); // 3
  /// ```
  Future<JsResult> evalFunction(
          {required String module,
          required String method,
          List<JsValue>? params}) =>
      LibFjs.instance.api.crateApiRuntimeJsAsyncContextEvalFunction(
          that: this, module: module, method: method, params: params);

  /// Evaluates JavaScript code with options.
  ///
  /// Provides fine-grained control over evaluation settings.
  /// Promise support is automatically enabled.
  ///
  /// ## Parameters
  ///
  /// - `code`: JavaScript code to evaluate
  /// - `options`: Evaluation options
  ///
  /// ## Returns
  ///
  /// The result of evaluation as a `JsValue`
  ///
  /// ## Throws
  ///
  /// - If code evaluation fails
  /// - If global attachment fails
  Future<JsResult> evalWithOptions(
          {required String code, required JsEvalOptions options}) =>
      LibFjs.instance.api.crateApiRuntimeJsAsyncContextEvalWithOptions(
          that: this, code: code, options: options);
}

@sealed
class JsAsyncRuntimeImpl extends RustOpaque implements JsAsyncRuntime {
  // Not to be used by end users
  JsAsyncRuntimeImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  JsAsyncRuntimeImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        LibFjs.instance.api.rust_arc_increment_strong_count_JsAsyncRuntime,
    rustArcDecrementStrongCount:
        LibFjs.instance.api.rust_arc_decrement_strong_count_JsAsyncRuntime,
    rustArcDecrementStrongCountPtr:
        LibFjs.instance.api.rust_arc_decrement_strong_count_JsAsyncRuntimePtr,
  );

  /// Executes a pending job.
  ///
  /// Runs one pending job if any are available. This method should be
  /// called repeatedly to process all pending asynchronous work.
  ///
  /// ## Returns
  ///
  /// `true` if a job was executed, `false` if no jobs were pending
  ///
  /// ## Throws
  ///
  /// If job execution fails
  Future<bool> executePendingJob() =>
      LibFjs.instance.api.crateApiRuntimeJsAsyncRuntimeExecutePendingJob(
        that: this,
      );

  /// Puts the runtime into idle state.
  ///
  /// Signals that the runtime is idle and may be used for background
  /// processing or resource cleanup.
  Future<void> idle() => LibFjs.instance.api.crateApiRuntimeJsAsyncRuntimeIdle(
        that: this,
      );

  /// Checks if there are pending jobs.
  ///
  /// Jobs are asynchronous tasks that need to be executed, such as
  /// promise callbacks or timer callbacks.
  ///
  /// ## Returns
  ///
  /// `true` if there are pending jobs, `false` otherwise
  Future<bool> isJobPending() =>
      LibFjs.instance.api.crateApiRuntimeJsAsyncRuntimeIsJobPending(
        that: this,
      );

  /// Returns memory usage statistics.
  ///
  /// Provides detailed information about current memory allocation
  /// and usage patterns.
  ///
  /// ## Returns
  ///
  /// A `MemoryUsage` struct containing memory statistics
  ///
  /// ## Example
  ///
  /// ```dart
  /// final usage = await runtime.memoryUsage();
  /// print('Total: ${usage.totalMemory} bytes');
  /// ```
  Future<MemoryUsage> memoryUsage() =>
      LibFjs.instance.api.crateApiRuntimeJsAsyncRuntimeMemoryUsage(
        that: this,
      );

  /// Forces garbage collection.
  ///
  /// Manually triggers garbage collection to free unused memory.
  /// This can be useful for memory management but should not be called
  /// excessively as it may impact performance.
  ///
  /// ## Example
  ///
  /// ```dart
  /// await runtime.runGc();
  /// ```
  Future<void> runGc() =>
      LibFjs.instance.api.crateApiRuntimeJsAsyncRuntimeRunGc(
        that: this,
      );

  /// Sets the garbage collection threshold.
  ///
  /// Configures when the runtime should trigger automatic garbage collection.
  ///
  /// ## Parameters
  ///
  /// - `threshold`: Memory threshold in bytes
  Future<void> setGcThreshold({required BigInt threshold}) =>
      LibFjs.instance.api.crateApiRuntimeJsAsyncRuntimeSetGcThreshold(
          that: this, threshold: threshold);

  /// Sets runtime info string.
  ///
  /// Sets informational metadata about the runtime instance.
  ///
  /// ## Parameters
  ///
  /// - `info`: Info string to set
  ///
  /// ## Throws
  ///
  /// If setting the info fails
  Future<void> setInfo({required String info}) => LibFjs.instance.api
      .crateApiRuntimeJsAsyncRuntimeSetInfo(that: this, info: info);

  /// Sets the maximum stack size.
  ///
  /// Limits the maximum depth of the JavaScript call stack to prevent
  /// stack overflow errors.
  ///
  /// ## Parameters
  ///
  /// - `limit`: Maximum stack size in bytes
  Future<void> setMaxStackSize({required BigInt limit}) => LibFjs.instance.api
      .crateApiRuntimeJsAsyncRuntimeSetMaxStackSize(that: this, limit: limit);

  /// Sets the memory limit.
  ///
  /// Once the memory limit is reached, JavaScript execution will fail
  /// with a memory limit error.
  ///
  /// ## Parameters
  ///
  /// - `limit`: Maximum memory in bytes
  ///
  /// ## Example
  ///
  /// ```dart
  /// await runtime.setMemoryLimit(limit: 16 * 1024 * 1024); // 16 MB
  /// ```
  Future<void> setMemoryLimit({required BigInt limit}) => LibFjs.instance.api
      .crateApiRuntimeJsAsyncRuntimeSetMemoryLimit(that: this, limit: limit);
}

@sealed
class JsContextImpl extends RustOpaque implements JsContext {
  // Not to be used by end users
  JsContextImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  JsContextImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        LibFjs.instance.api.rust_arc_increment_strong_count_JsContext,
    rustArcDecrementStrongCount:
        LibFjs.instance.api.rust_arc_decrement_strong_count_JsContext,
    rustArcDecrementStrongCountPtr:
        LibFjs.instance.api.rust_arc_decrement_strong_count_JsContextPtr,
  );

  /// Evaluates JavaScript code.
  ///
  /// Evaluates the given code string with default options.
  /// Promise/async operations are not supported in sync context.
  ///
  /// ## Parameters
  ///
  /// - `code`: JavaScript code to evaluate
  ///
  /// ## Returns
  ///
  /// The result of evaluation as a `JsValue`
  ///
  /// ## Example
  ///
  /// ```dart
  /// final result = context.eval(code: '2 + 2');
  /// print(result.value); // 4
  /// ```
  JsResult eval({required String code}) =>
      LibFjs.instance.api.crateApiRuntimeJsContextEval(that: this, code: code);

  /// Evaluates JavaScript code from a file.
  ///
  /// Reads and executes JavaScript code from the specified file path.
  ///
  /// ## Parameters
  ///
  /// - `path`: Path to the JavaScript file
  ///
  /// ## Returns
  ///
  /// The result of evaluation as a `JsValue`
  ///
  /// ## Throws
  ///
  /// - If promise option is enabled (not supported in sync context)
  /// - If file cannot be read
  /// - If code evaluation fails
  ///
  /// ## Example
  ///
  /// ```dart
  /// final result = context.evalFile(path: '/path/to/script.js');
  /// ```
  JsResult evalFile({required String path}) => LibFjs.instance.api
      .crateApiRuntimeJsContextEvalFile(that: this, path: path);

  /// Evaluates JavaScript code from a file with options.
  ///
  /// Reads and executes JavaScript code from the specified file path
  /// with custom evaluation options.
  ///
  /// ## Parameters
  ///
  /// - `path`: Path to the JavaScript file
  /// - `options`: Evaluation options
  ///
  /// ## Returns
  ///
  /// The result of evaluation as a `JsValue`
  ///
  /// ## Throws
  ///
  /// - If promise option is enabled (not supported in sync context)
  /// - If file cannot be read
  /// - If code evaluation fails
  JsResult evalFileWithOptions(
          {required String path, required JsEvalOptions options}) =>
      LibFjs.instance.api.crateApiRuntimeJsContextEvalFileWithOptions(
          that: this, path: path, options: options);

  /// Evaluates JavaScript code with options.
  ///
  /// Provides fine-grained control over evaluation settings.
  /// Promise/async operations are not supported in sync context.
  ///
  /// ## Parameters
  ///
  /// - `code`: JavaScript code to evaluate
  /// - `options`: Evaluation options
  ///
  /// ## Returns
  ///
  /// The result of evaluation as a `JsValue`
  ///
  /// ## Throws
  ///
  /// - If promise option is enabled (not supported in sync context)
  /// - If code evaluation fails
  JsResult evalWithOptions(
          {required String code, required JsEvalOptions options}) =>
      LibFjs.instance.api.crateApiRuntimeJsContextEvalWithOptions(
          that: this, code: code, options: options);
}

@sealed
class JsEngineImpl extends RustOpaque implements JsEngine {
  // Not to be used by end users
  JsEngineImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  JsEngineImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        LibFjs.instance.api.rust_arc_increment_strong_count_JsEngine,
    rustArcDecrementStrongCount:
        LibFjs.instance.api.rust_arc_decrement_strong_count_JsEngine,
    rustArcDecrementStrongCountPtr:
        LibFjs.instance.api.rust_arc_decrement_strong_count_JsEnginePtr,
  );

  /// Calls a function in a module.
  ///
  /// Imports the specified module and invokes one of its exported functions.
  ///
  /// ## Parameters
  /// - `module`: The module name to import
  /// - `method`: The function name to call (must be exported from the module)
  /// - `params`: Optional parameters to pass to the function
  ///
  /// ## Returns
  /// The result of the function call as a `JsValue`
  ///
  /// ## Throws
  /// - If the engine is not initialized
  /// - If the module cannot be imported
  /// - If the function does not exist
  /// - If the function call fails
  ///
  /// ## Example
  /// ```dart
  /// // Call a function with parameters
  /// final result = await engine.call(
  ///   module: 'math-utils',
  ///   method: 'add',
  ///   params: [JsValue.integer(1), JsValue.integer(2)],
  /// );
  /// print(result.value); // 3
  ///
  /// // Call a function without parameters
  /// final version = await engine.call(
  ///   module: 'config',
  ///   method: 'getVersion',
  /// );
  /// ```
  Future<JsValue> call(
          {required String module,
          required String method,
          List<JsValue>? params}) =>
      LibFjs.instance.api.crateApiEngineJsEngineCall(
          that: this, module: module, method: method, params: params);

  /// Clears all dynamically declared modules.
  ///
  /// Removes all modules that were registered via `declareNewModule` or `declareNewModules`.
  /// Built-in modules are not affected.
  ///
  /// ## Throws
  /// - If the engine is not initialized
  /// - If module storage is not available
  ///
  /// ## Example
  /// ```dart
  /// await engine.clearNewModules();
  /// ```
  Future<void> clearNewModules() =>
      LibFjs.instance.api.crateApiEngineJsEngineClearNewModules(
        that: this,
      );

  /// Returns the underlying async context.
  ///
  /// This can be used to access lower-level context operations
  /// if needed.
  JsAsyncContext get context =>
      LibFjs.instance.api.crateApiEngineJsEngineContext(
        that: this,
      );

  /// Declares a new module without executing it.
  ///
  /// The module will be available for import in subsequent evaluations.
  /// Use this when you need to register a module for later use.
  ///
  /// ## Parameters
  /// - `module`: The module to declare (name and source code)
  ///
  /// ## Throws
  /// - If the engine is not initialized
  /// - If module storage is not available
  ///
  /// ## Example
  /// ```dart
  /// await engine.declareNewModule(module: JsModule.fromCode(
  ///   module: 'math-utils',
  ///   code: 'export function add(a, b) { return a + b; }',
  /// ));
  ///
  /// // Later, import and use it
  /// final result = await engine.eval(source: JsCode.code('''
  ///   const { add } = await import('math-utils');
  ///   add(1, 2)
  /// '''));
  /// ```
  Future<void> declareNewModule({required JsModule module}) =>
      LibFjs.instance.api
          .crateApiEngineJsEngineDeclareNewModule(that: this, module: module);

  /// Declares multiple new modules without executing them.
  ///
  /// Convenience method for registering multiple modules at once.
  ///
  /// ## Parameters
  /// - `modules`: List of modules to declare
  ///
  /// ## Throws
  /// - If the engine is not initialized
  /// - If any module declaration fails
  ///
  /// ## Example
  /// ```dart
  /// await engine.declareNewModules(modules: [
  ///   JsModule.fromCode(module: 'utils', code: 'export const VERSION = "1.0"'),
  ///   JsModule.fromCode(module: 'helpers', code: 'export function log(x) { console.log(x); }'),
  /// ]);
  /// ```
  Future<void> declareNewModules({required List<JsModule> modules}) => LibFjs
      .instance.api
      .crateApiEngineJsEngineDeclareNewModules(that: this, modules: modules);

  /// Disposes the engine and releases resources.
  ///
  /// After disposal, the engine cannot be used anymore.
  /// Any pending operations will fail.
  ///
  /// ## Throws
  /// - If the engine is already disposed
  Future<void> dispose() => LibFjs.instance.api.crateApiEngineJsEngineDispose(
        that: this,
      );

  /// Returns whether the engine has been disposed.
  ///
  /// Once disposed, the engine cannot be used anymore.
  bool get disposed => LibFjs.instance.api.crateApiEngineJsEngineDisposed(
        that: this,
      );

  /// Evaluates JavaScript code and returns the result.
  ///
  /// Supports both synchronous and asynchronous JavaScript code.
  /// Top-level await is enabled by default.
  ///
  /// ## Parameters
  /// - `source`: The JavaScript code to evaluate (string, path, or bytes)
  /// - `options`: Optional evaluation settings (defaults to promise-enabled mode)
  ///
  /// ## Returns
  /// The result of the evaluation as a `JsValue`
  ///
  /// ## Throws
  /// - If the engine is not initialized
  /// - If the engine is disposed
  /// - If JavaScript execution fails
  ///
  /// ## Example
  /// ```dart
  /// // Simple expression
  /// final result = await engine.eval(source: JsCode.code('1 + 1'));
  /// print(result.value); // 2
  ///
  /// // Async code
  /// final asyncResult = await engine.eval(source: JsCode.code('''
  ///   await new Promise(resolve => setTimeout(() => resolve('done'), 100))
  /// '''));
  /// ```
  Future<JsValue> eval({required JsCode source, JsEvalOptions? options}) =>
      LibFjs.instance.api.crateApiEngineJsEngineEval(
          that: this, source: source, options: options);

  /// Evaluates a module (registers and executes it).
  ///
  /// Unlike `declareNewModule`, this method also executes the module's
  /// top-level code and returns its default export or last expression value.
  ///
  /// ## Parameters
  /// - `module`: The module to evaluate (name and source code)
  ///
  /// ## Returns
  /// The result of module evaluation
  ///
  /// ## Throws
  /// - If the engine is not initialized
  /// - If module storage is not available
  /// - If module execution fails
  ///
  /// ## Example
  /// ```dart
  /// final result = await engine.evaluateModule(module: JsModule.fromCode(
  ///   module: 'init',
  ///   code: '''
  ///     console.log("Module initializing...");
  ///     export default { version: "1.0" };
  ///   ''',
  /// ));
  /// ```
  Future<JsValue> evaluateModule({required JsModule module}) =>
      LibFjs.instance.api
          .crateApiEngineJsEngineEvaluateModule(that: this, module: module);

  /// Gets all declared module names.
  ///
  /// Returns a list of all dynamically registered module names.
  ///
  /// ## Returns
  /// List of module names as strings
  ///
  /// ## Throws
  /// - If the engine is not initialized
  /// - If module storage is not available
  ///
  /// ## Example
  /// ```dart
  /// final modules = await engine.getDeclaredModules();
  /// print('Declared modules: $modules');
  /// ```
  Future<List<String>> getDeclaredModules() =>
      LibFjs.instance.api.crateApiEngineJsEngineGetDeclaredModules(
        that: this,
      );

  /// Initializes the engine with a bridge callback for Dart-JS communication.
  ///
  /// The bridge callback is invoked when JavaScript calls `fjs.bridge_call(value)`.
  /// This enables bidirectional communication between Dart and JavaScript.
  ///
  /// ## Parameters
  /// - `bridge`: A callback function that receives a `JsValue` from JavaScript
  ///   and returns a `JsResult` back to JavaScript
  ///
  /// ## Throws
  /// - If the engine is already disposed
  /// - If the engine is already initialized
  ///
  /// ## Example
  /// ```dart
  /// await engine.init(bridge: (value) async {
  ///   print('Received from JS: \$value');
  ///   return JsResult.ok(JsValue.string('Response from Dart'));
  /// });
  /// ```
  Future<void> init({required FutureOr<JsResult> Function(JsValue) bridge}) =>
      LibFjs.instance.api
          .crateApiEngineJsEngineInit(that: this, bridge: bridge);

  /// Initializes the engine without a bridge callback.
  ///
  /// Use this when you don't need Dart-JS communication via the bridge.
  /// JavaScript code can still run, but `fjs.bridge_call()` will not be available.
  ///
  /// ## Throws
  /// - If the engine is already disposed
  /// - If the engine is already initialized
  ///
  /// ## Example
  /// ```dart
  /// await engine.initWithoutBridge();
  /// ```
  Future<void> initWithoutBridge() =>
      LibFjs.instance.api.crateApiEngineJsEngineInitWithoutBridge(
        that: this,
      );

  /// Checks if a module is declared.
  ///
  /// ## Parameters
  /// - `moduleName`: The name of the module to check
  ///
  /// ## Returns
  /// `true` if the module exists, `false` otherwise
  ///
  /// ## Throws
  /// - If the engine is not initialized
  /// - If module storage is not available
  ///
  /// ## Example
  /// ```dart
  /// if (await engine.isModuleDeclared(moduleName: 'my-module')) {
  ///   print('Module exists!');
  /// }
  /// ```
  Future<bool> isModuleDeclared({required String moduleName}) =>
      LibFjs.instance.api.crateApiEngineJsEngineIsModuleDeclared(
          that: this, moduleName: moduleName);

  /// Returns whether the engine is running and ready for execution.
  ///
  /// The engine is running after `init()` or `initWithoutBridge()`
  /// has been called successfully.
  bool get running => LibFjs.instance.api.crateApiEngineJsEngineRunning(
        that: this,
      );
}

@sealed
class JsRuntimeImpl extends RustOpaque implements JsRuntime {
  // Not to be used by end users
  JsRuntimeImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  JsRuntimeImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        LibFjs.instance.api.rust_arc_increment_strong_count_JsRuntime,
    rustArcDecrementStrongCount:
        LibFjs.instance.api.rust_arc_decrement_strong_count_JsRuntime,
    rustArcDecrementStrongCountPtr:
        LibFjs.instance.api.rust_arc_decrement_strong_count_JsRuntimePtr,
  );

  /// Executes a pending job.
  ///
  /// Runs one pending job if any are available. This method should be
  /// called repeatedly to process all pending asynchronous work.
  ///
  /// ## Returns
  ///
  /// `true` if a job was executed, `false` if no jobs were pending
  ///
  /// ## Throws
  ///
  /// If job execution fails
  bool executePendingJob() =>
      LibFjs.instance.api.crateApiRuntimeJsRuntimeExecutePendingJob(
        that: this,
      );

  /// Checks if there are pending jobs.
  ///
  /// Jobs are asynchronous tasks that need to be executed, such as
  /// promise callbacks or timer callbacks.
  ///
  /// ## Returns
  ///
  /// `true` if there are pending jobs, `false` otherwise
  bool isJobPending() =>
      LibFjs.instance.api.crateApiRuntimeJsRuntimeIsJobPending(
        that: this,
      );

  /// Returns memory usage statistics.
  ///
  /// Provides detailed information about current memory allocation
  /// and usage patterns.
  ///
  /// ## Returns
  ///
  /// A `MemoryUsage` struct containing memory statistics
  ///
  /// ## Example
  ///
  /// ```dart
  /// final usage = runtime.memoryUsage();
  /// print('Total: ${usage.totalMemory} bytes');
  /// ```
  MemoryUsage memoryUsage() =>
      LibFjs.instance.api.crateApiRuntimeJsRuntimeMemoryUsage(
        that: this,
      );

  /// Forces garbage collection.
  ///
  /// Manually triggers garbage collection to free unused memory.
  /// This can be useful for memory management but should not be called
  /// excessively as it may impact performance.
  ///
  /// ## Example
  ///
  /// ```dart
  /// runtime.runGc();
  /// ```
  void runGc() => LibFjs.instance.api.crateApiRuntimeJsRuntimeRunGc(
        that: this,
      );

  /// Sets dump flags for debugging.
  ///
  /// Configures debug output flags for the QuickJS engine.
  /// Useful for development and troubleshooting.
  ///
  /// ## Parameters
  ///
  /// - `flags`: Debug flags to set
  void setDumpFlags({required BigInt flags}) => LibFjs.instance.api
      .crateApiRuntimeJsRuntimeSetDumpFlags(that: this, flags: flags);

  /// Sets the garbage collection threshold.
  ///
  /// Configures when the runtime should trigger automatic garbage collection.
  ///
  /// ## Parameters
  ///
  /// - `threshold`: Memory threshold in bytes
  void setGcThreshold({required BigInt threshold}) => LibFjs.instance.api
      .crateApiRuntimeJsRuntimeSetGcThreshold(that: this, threshold: threshold);

  /// Sets runtime info string.
  ///
  /// Sets informational metadata about the runtime instance.
  ///
  /// ## Parameters
  ///
  /// - `info`: Info string to set
  ///
  /// ## Throws
  ///
  /// If setting the info fails
  void setInfo({required String info}) => LibFjs.instance.api
      .crateApiRuntimeJsRuntimeSetInfo(that: this, info: info);

  /// Sets the maximum stack size.
  ///
  /// Limits the maximum depth of the JavaScript call stack to prevent
  /// stack overflow errors.
  ///
  /// ## Parameters
  ///
  /// - `limit`: Maximum stack size in bytes
  void setMaxStackSize({required BigInt limit}) => LibFjs.instance.api
      .crateApiRuntimeJsRuntimeSetMaxStackSize(that: this, limit: limit);

  /// Sets the memory limit for the runtime.
  ///
  /// Once the memory limit is reached, JavaScript execution will fail
  /// with a memory limit error.
  ///
  /// ## Parameters
  ///
  /// - `limit`: Maximum memory in bytes
  ///
  /// ## Example
  ///
  /// ```dart
  /// runtime.setMemoryLimit(limit: 16 * 1024 * 1024); // 16 MB
  /// ```
  void setMemoryLimit({required BigInt limit}) => LibFjs.instance.api
      .crateApiRuntimeJsRuntimeSetMemoryLimit(that: this, limit: limit);
}

@sealed
class MemoryUsageImpl extends RustOpaque implements MemoryUsage {
  // Not to be used by end users
  MemoryUsageImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MemoryUsageImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        LibFjs.instance.api.rust_arc_increment_strong_count_MemoryUsage,
    rustArcDecrementStrongCount:
        LibFjs.instance.api.rust_arc_decrement_strong_count_MemoryUsage,
    rustArcDecrementStrongCountPtr:
        LibFjs.instance.api.rust_arc_decrement_strong_count_MemoryUsagePtr,
  );

  PlatformInt64 get arrayCount =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageArrayCount(
        that: this,
      );

  PlatformInt64 get atomCount =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageAtomCount(
        that: this,
      );

  PlatformInt64 get atomSize =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageAtomSize(
        that: this,
      );

  PlatformInt64 get binaryObjectCount =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageBinaryObjectCount(
        that: this,
      );

  PlatformInt64 get binaryObjectSize =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageBinaryObjectSize(
        that: this,
      );

  PlatformInt64 get cFuncCount =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageCFuncCount(
        that: this,
      );

  PlatformInt64 get fastArrayCount =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageFastArrayCount(
        that: this,
      );

  PlatformInt64 get fastArrayElements =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageFastArrayElements(
        that: this,
      );

  PlatformInt64 get jsFuncCodeSize =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageJsFuncCodeSize(
        that: this,
      );

  PlatformInt64 get jsFuncCount =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageJsFuncCount(
        that: this,
      );

  PlatformInt64 get jsFuncPc2LineCount =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageJsFuncPc2LineCount(
        that: this,
      );

  PlatformInt64 get jsFuncPc2LineSize =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageJsFuncPc2LineSize(
        that: this,
      );

  PlatformInt64 get jsFuncSize =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageJsFuncSize(
        that: this,
      );

  PlatformInt64 get mallocCount =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageMallocCount(
        that: this,
      );

  PlatformInt64 get mallocLimit =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageMallocLimit(
        that: this,
      );

  PlatformInt64 get mallocSize =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageMallocSize(
        that: this,
      );

  PlatformInt64 get memoryUsedCount =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageMemoryUsedCount(
        that: this,
      );

  PlatformInt64 get memoryUsedSize =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageMemoryUsedSize(
        that: this,
      );

  PlatformInt64 get objCount =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageObjCount(
        that: this,
      );

  PlatformInt64 get objSize =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageObjSize(
        that: this,
      );

  PlatformInt64 get propCount =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsagePropCount(
        that: this,
      );

  PlatformInt64 get propSize =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsagePropSize(
        that: this,
      );

  PlatformInt64 get shapeCount =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageShapeCount(
        that: this,
      );

  PlatformInt64 get shapeSize =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageShapeSize(
        that: this,
      );

  PlatformInt64 get strCount =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageStrCount(
        that: this,
      );

  PlatformInt64 get strSize =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageStrSize(
        that: this,
      );

  /// Returns a human-readable summary of memory usage.
  ///
  /// Provides a formatted string containing key memory statistics
  /// including total memory, object count, function count, and string count.
  ///
  /// ## Returns
  ///
  /// A formatted string summarizing memory usage
  ///
  /// ## Example
  ///
  /// ```dart
  /// final memory = await runtime.memoryUsage();
  /// print(memory.summary());
  /// // Output: Memory: 123456 bytes, Objects: 42, Functions: 10, Strings: 25
  /// ```
  String summary() => LibFjs.instance.api.crateApiRuntimeMemoryUsageSummary(
        that: this,
      );

  /// Returns total allocation count.
  ///
  /// This represents the total number of memory allocations
  /// performed by the JavaScript runtime.
  ///
  /// ## Returns
  ///
  /// Total number of allocations
  PlatformInt64 get totalAllocations =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageTotalAllocations(
        that: this,
      );

  /// Returns total memory used in bytes.
  ///
  /// This represents the total amount of memory currently allocated
  /// by the JavaScript runtime.
  ///
  /// ## Returns
  ///
  /// Total memory usage in bytes
  PlatformInt64 get totalMemory =>
      LibFjs.instance.api.crateApiRuntimeMemoryUsageTotalMemory(
        that: this,
      );
}
